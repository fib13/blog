[{"uri":"https://www.shisanshiji.com/troubleshooting/elasticsearch-troubleshooting/","title":"Elasticsearch 问题排查","tags":null,"description":"","content":"问题列表如下：\n 集群中包含未分配的副本导致集群变为 Red 状态  集群中包含未分配的副本导致集群变为 Red 状态 查看集群状态信息 首先确定原因。\n查看整体健康信息 $ curl -u \u0026#39;elastic:password\u0026#39; \u0026#39;http://127.0.0.1:9200/_cluster/health?pretty\u0026#39; { \u0026#34;cluster_name\u0026#34; : \u0026#34;elasticsearch\u0026#34;, \u0026#34;status\u0026#34; : \u0026#34;red\u0026#34;, \u0026#34;timed_out\u0026#34; : false, \u0026#34;number_of_nodes\u0026#34; : 1, \u0026#34;number_of_data_nodes\u0026#34; : 1, \u0026#34;active_primary_shards\u0026#34; : 69, \u0026#34;active_shards\u0026#34; : 69, \u0026#34;relocating_shards\u0026#34; : 0, \u0026#34;initializing_shards\u0026#34; : 0, \u0026#34;unassigned_shards\u0026#34; : 1, \u0026#34;delayed_unassigned_shards\u0026#34; : 0, \u0026#34;number_of_pending_tasks\u0026#34; : 0, \u0026#34;number_of_in_flight_fetch\u0026#34; : 0, \u0026#34;task_max_waiting_in_queue_millis\u0026#34; : 0, \u0026#34;active_shards_percent_as_number\u0026#34; : 98.57142857142858 } 主要关注其中的 unassigned_shards 指标，其代表已经在集群状态中存在的分片，但是实际在集群里又找不着。通常未分配分片的来源是未分配的副本。比如，一个有 5 分片和 1 副本的索引，在单节点集群上，就会有 5 个未分配副本分片。如果你的集群是 red 状态，也会长期保有未分配分片（因为缺少主分片）。其他指标解释：\n  initializing_shards 是刚刚创建的分片的个数。比如，当你刚创建第一个索引，分片都会短暂的处于 initializing 状态。这通常会是一个临时事件，分片不应该长期停留在 initializing 状态。你还可能在节点刚重启的时候看到 initializing 分片：当分片从磁盘上加载后，它们会从 initializing 状态开始。\n  number_of_nodes 和 number_of_data_nodes：可由字面意思理解。\n  active_primary_shards：指出你集群中的主分片数量。这是涵盖了所有索引的汇总值。\n  active_shards：所有索引的所有分片的汇总值，即包括副本分片。\n  relocating_shards：显示当前正在从一个节点迁往其他节点的分片的数量。通常来说应该是 0，不过在 Elasticsearch 发现集群不太均衡时，该值会上涨。比如说：添加了一个新节点，或者下线了一个节点。\n  active_shards_percent_as_number：活跃分片数占总分片数比例。\n  查看每个索引的健康信息 我们还可以通过 level 参数查看更详细的信息：\ncurl -u elastic:password \u0026#39;http://127.0.0.1:9200/_cluster/health?pretty=true\u0026amp;level=indices\u0026#39; { \u0026#34;cluster_name\u0026#34; : \u0026#34;elasticsearch\u0026#34;, \u0026#34;status\u0026#34; : \u0026#34;red\u0026#34;, \u0026#34;timed_out\u0026#34; : false, \u0026#34;number_of_nodes\u0026#34; : 1, \u0026#34;number_of_data_nodes\u0026#34; : 1, \u0026#34;active_primary_shards\u0026#34; : 69, \u0026#34;active_shards\u0026#34; : 69, \u0026#34;relocating_shards\u0026#34; : 0, \u0026#34;initializing_shards\u0026#34; : 0, \u0026#34;unassigned_shards\u0026#34; : 2, \u0026#34;delayed_unassigned_shards\u0026#34; : 0, \u0026#34;number_of_pending_tasks\u0026#34; : 0, \u0026#34;number_of_in_flight_fetch\u0026#34; : 0, \u0026#34;task_max_waiting_in_queue_millis\u0026#34; : 0, \u0026#34;active_shards_percent_as_number\u0026#34; : 97.1830985915493, \u0026#34;indices\u0026#34; : { ... \u0026#34;kubernetes-2021.08.13\u0026#34; : { \u0026#34;status\u0026#34; : \u0026#34;green\u0026#34;, \u0026#34;number_of_shards\u0026#34; : 1, \u0026#34;number_of_replicas\u0026#34; : 0, \u0026#34;active_primary_shards\u0026#34; : 1, \u0026#34;active_shards\u0026#34; : 1, \u0026#34;relocating_shards\u0026#34; : 0, \u0026#34;initializing_shards\u0026#34; : 0, \u0026#34;unassigned_shards\u0026#34; : 1 }, ... } 添加 level=indices 参数会在集群健康信息里添加一个索引清单，以及有关每个索引的细节（状态、分片数、未分配分片数等等），一旦我们询问要索引的输出，哪个索引有问题立马就很清楚了：kubernetes-2021.08.13。\n查看每个索引的每个分片的健康信息 我们可以更细致的输出索引的每个分片的健康信息，通过添加参数 level=shards 获取。\ncurl -u \u0026#39;elastic:password\u0026#39; \u0026#39;http://127.0.0.1:9200/_cluster/health?pretty=true\u0026amp;level=shards\u0026#39; 通过添加 level=indices 参数可以列出每个索引里每个分片的状态和位置。这个输出有时候很有用，但是由于太过详细会比较难用。\n查看未分配分片的索引及原因 curl -u \u0026#39;elastic:password\u0026#39; \u0026#39;http://127.0.0.1:9200/_cat/shards?v\u0026amp;h=index,shard,prirep,state,unassigned.reason\u0026#39; index shard prirep state unassigned.reason .apm-custom-link 0 p STARTED ... kubernetes-2021.10.10 0 p STARTED kubernetes-2021.11.03 0 p UNASSIGNED CLUSTER_RECOVERED kubernetes-2021.08.19 0 p STARTED ... unassigned.reason 值说明：\n INDEX_CREATED: 由于创建索引的 API 导致未分配。 CLUSTER_RECOVERED: 由于完全集群恢复导致未分配。 INDEX_REOPENED: 由于打开 open 或关闭 close 一个索引导致未分配。 DANGLING_INDEX_IMPORTED: 由于导入 dangling 索引的结果导致未分配。 NEW_INDEX_RESTORED: 由于恢复到新索引导致未分配。 EXISTING_INDEX_RESTORED: 由于恢复到已关闭的索引导致未分配。 REPLICA_ADDED: 由于显式添加副本分片导致未分配。 ALLOCATION_FAILED: 由于分片分配失败导致未分配。 NODE_LEFT: 由于承载该分片的节点离开集群导致未分配。 REINITIALIZED: 由于当分片从开始移动到初始化时导致未分配（例如，使用Shadow 副本分片）。 REROUTE_CANCELLED: 作为显式取消重新路由命令的结果取消分配。 REALLOCATED_REPLICA: 确定更好的副本位置被标定使用，导致现有的副本分配被取消，出现未分配。  解决方法 由两种方法可解决，任选其中一种即可。\n手动分配 curl -u \u0026#39;elastic:password\u0026#39; -H \u0026#34;Content-Type: application/json\u0026#34; \u0026#39;http://127.0.0.1:9200/_cluster/reroute\u0026#39; -d \u0026#39;{ \u0026#34;commands\u0026#34;: [{ \u0026#34;allocate\u0026#34;: { \u0026#34;index\u0026#34;: \u0026#34;\u0026lt;索引名称\u0026gt;\u0026#34;, \u0026#34;shard\u0026#34;: \u0026lt;分片编号\u0026gt;, \u0026#34;node\u0026#34;: \u0026#34;\u0026lt;节点 ID\u0026gt;\u0026#34;, \u0026#34;allow_primary\u0026#34;: true } }] }\u0026#39; 批处理脚本：\n#!/bin/bash array=( node1 node2 node3 ) node_counter=0 length=${#array[@]} IFS=$\u0026#39;\\n\u0026#39; for line in $(curl -s \u0026#39;http://127.0.0.1:9200/_cat/shards\u0026#39;| fgrep UNASSIGNED); do INDEX=$(echo $line | (awk \u0026#39;{print $1}\u0026#39;)) SHARD=$(echo $line | (awk \u0026#39;{print $2}\u0026#39;)) NODE=${array[$node_counter]} echo $NODE curl -XPOST \u0026#39;http://127.0.0.1:9200/_cluster/reroute\u0026#39; -d \u0026#39;{ \u0026#34;commands\u0026#34;: [ { \u0026#34;allocate\u0026#34;: { \u0026#34;index\u0026#34;: \u0026#34;\u0026#39;$INDEX\u0026#39;\u0026#34;, \u0026#34;shard\u0026#34;: \u0026#39;$SHARD\u0026#39;, \u0026#34;node\u0026#34;: \u0026#34;\u0026#39;$NODE\u0026#39;\u0026#34;, \u0026#34;allow_primary\u0026#34;: true } } ] }\u0026#39; node_counter=$(((node_counter)%length +1)) done 重新建立副本 如果在上面的命令执行输出结果中，假如所有的 primary shards 都是正常的，所有 replica shards 有问题，有一种快速恢复的方法，就是强制删除掉 replica shards，让 Elasticsearch 自主重新生成。\n首先先将出问题的索引的副本为 0：\ncurl -u \u0026#39;elastic:password\u0026#39; -H \u0026#34;Content-Type: application/json\u0026#34; -X PUT \u0026#39;http://127.0.0.1:9200/\u0026lt;索引名称\u0026gt;/_settings\u0026#39; -d \u0026#39;{ \u0026#34;index\u0026#34;: {\u0026#34;number_of_replicas\u0026#34;: 0}}\u0026#39; 然后观察集群状态，最后通过命令在恢复期索引副本数据：\ncurl -u \u0026#39;elastic:password\u0026#39; -H \u0026#34;Content-Type: application/json\u0026#34; -X PUT \u0026#39;http://127.0.0.1:9200/\u0026lt;索引名称\u0026gt;/_settings\u0026#39; -d \u0026#39;{ \u0026#34;index\u0026#34;: {\u0026#34;number_of_replicas\u0026#34;: 1}}\u0026#39; 等待节点自动分配后，集群成功恢复成 green。\n"},{"uri":"https://www.shisanshiji.com/operation-guide/hugo-githubactiongithub-pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","title":"Hugo\u0026Github Action\u0026Github Pages 搭建个人博客","tags":null,"description":"","content":"介绍 大致的流程如下：\n 首先通过 Hugo 生成博客网站，并进行配置、添加内容。 然后在 Github 上创建一个 blog 仓库，并将博客源码推送到 blog 仓库的 main 分支。 接着使用 Github Action 构建出静态网站，并自动推送至 gh-pages 分支。 最后配置 Github Pages 绑定 gh-pages 分支上的内容，就可以使用生成或配置的域名进行访问。  先决条件 准备 Git（必须） 如未安装 Git，参考 Git 安装指南 进行安装。\n安装完成后，可以通过 git version 命令进行验证。\n$ git version git version 2.29.2.windows.2 如果你是第一次安装，则需要初始化 Git 用户信息。将以下内容中邮箱和名字替换为合适的值并运行。\n$ git config --global user.email \u0026#34;you@example.com\u0026#34; $ git config --global user.name \u0026#34;Your Name\u0026#34; 准备 Github 仓库（必须） 在 Github 上创建 blog 仓库，你也可以选择其他合适的名称作为博客的仓库。\n点击查看配置仓库页面  准备 Hugo（必须） 如未安装 Hugo，参考 Hugo 安装指南 进行安装。\n安装完成后，可以通过 hugo version 命令进行验证。\n$ hugo version hugo v0.89.1-B6A4AE4A+extended windows/amd64 BuildDate=2021-11-05T15:44:32Z VendorInfo=gohugoio 准备域名（可选） 部署至 Github 上以后，默认会使用 \u0026lt;username\u0026gt;.github.io 域名访问你的博客。如果你想使用自己的域名，需要购买一个域名备用。可在腾讯云、阿里云或其他域名供应商购买。\n创建博客 生成博客 使用 hugo new site blog 命令来生成博客源码仓库。\n$ hugo new site blog Congratulations! Your new Hugo site is created in C:\\Users\\Peng.Gao\\Desktop\\Blog\\blog. Just a few more steps and you are ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; command. 2. Perhaps you want to add some content. You can add single files with \u0026#34;hugo new \u0026lt;SECTIONNAME\u0026gt;\\\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 3. Start the built-in live server via \u0026#34;hugo server\u0026#34;. Visit https://gohugo.io/ for quickstart guide and full documentation. 切换当前目录至 blog 目录，可以使用 tree 命令查看目录的结构。\n$ cd blog $ tree -L 1 . |-- archetypes |-- config.toml |-- content |-- data |-- layouts |-- static `-- themes 6 directories, 1 file 应用主题 你可以选择一个喜欢的主题应用于你的博客，此博客使用的主题为 Ace documentation。\n$ git submodule add https://github.com/vantagedesign/ace-documentation themes/ace-documentation Cloning into \u0026#39;C:/Users/Peng.Gao/Desktop/Blog/docs/themes/ace-documentation\u0026#39;... remote: Enumerating objects: 555, done. remote: Counting objects: 100% (139/139), done. remote: Compressing objects: 100% (90/90), done. remote: Total 555 (delta 57), reused 88 (delta 35), pack-reused 416 Receiving objects: 100% (555/555), 2.15 MiB | 683.00 KiB/s, done. Resolving deltas: 100% (191/191), done. warning: LF will be replaced by CRLF in .gitmodules. The file will have its original line endings in your working directory 接下来需要根据你应用主题的教程来配置 config.toml 文件，主题配置教程在刚才你寻找的主题页面上查看。\n还可以根据主题的样例去新添加一些内容，在此不过多说明。\n构建博客 配置完成后，在 blog 目录下可以使用 hugo server 启动 Web 服务器。Hugo 会构建站点内容到内存中并在检测到文件更改后重新渲染，方便在开发环境中实时预览对站点所做的更改。\n$ hugo server Start building sites … hugo v0.89.1-B6A4AE4A+extended windows/amd64 BuildDate=2021-11-05T15:44:32Z VendorInfo=gohugoio | EN -------------------+----- Pages | 18 Paginator pages | 0 Non-page files | 0 Static files | 26 Processed images | 0 Aliases | 0 Sitemaps | 1 Cleaned | 0 Built in 173 ms Watching for changes in C:\\Users\\Peng.Gao\\Desktop\\Blog\\docs\\{archetypes,content,data,layouts,static,themes} Watching for config changes in C:\\Users\\Peng.Gao\\Desktop\\Blog\\docs\\config.toml Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 如果你在远端开发，可以使用 hugo server --bind 0.0.0.0 配置绑定的网卡。 如果你想更换端口号，也可以使用 hugo server -p 80 配置监听端口号。 如果在调试阶段需要输出处于草稿状态的文章（通过在文章注释中添加 draft: true 配置），则需要使用 hugo server -D 来渲染草稿。\n想了解更多的选项，运行 hugo --help 来查看它们的说明。\n预览效果满意后，可以使用 hugo 命令进行构建。\n$ hugo Start building sites … hugo v0.89.1-B6A4AE4A+extended windows/amd64 BuildDate=2021-11-05T15:44:32Z VendorInfo=gohugoio | EN -------------------+----- Pages | 18 Paginator pages | 0 Non-page files | 0 Static files | 26 Processed images | 0 Aliases | 0 Sitemaps | 1 Cleaned | 0 Total in 200 ms 构建完成后，再观察 blog 目录，会发现出现了新的目录为 public，这个目录就是我们构建出来的静态网站，通过 tree 命令观察 public，就是一个静态页面的结构。\n$ tree -L 1 public/ public/ |-- 404.html |-- categories |-- css |-- img |-- index.html |-- index.json |-- js |-- learn-notes |-- lib |-- operation-guide |-- plugins |-- sitemap.xml |-- tags `-- webfonts 10 directories, 4 files 部署至 Github 推送博客源码 现在，我们就可以将 blog 目录中的源码推送至 Github 远程仓库的 main 分支了。\n但在推送前，应该还需要忽略一些文件。思考一下介绍时所描述的大致步骤，你的博客源码是存储在 main 分支的，经过自动构建才会最新生成的 public 文件中的内容推送至 gh-pages 分支，我们并不需要将 public 目录推送至 main 分支，因此需要忽略 public 目录。此外还可能需要忽略一些其他的文件或目录，比如启动 Web 服务时所生成的 .hugo_build.lock 文件和 resources 目录，或者由编辑器产生的本地配置目录及文件。以下是我在 .gitignore 文件中忽略的内容，仅供参考。\n*.lock *.vscode *.log *.idea resources/ public/ 添加完 .gitignore 文件以后，你可以添加 Github 远程仓库并推送至 main 分支。\n$ git init $ git add . $ git commit -m \u0026#34;init\u0026#34; $ git branch -M main $ git remote add origin https://github.com/jugggao/blog.git $ git push -u origin main  注意\n需要更换远程仓库 URL 中的名称为你的 Github 用户名。  使用 Github Action 自动构建 我们将博客源码上传至 main 分支之后，就需要通过 Github Action 进行自动构建了，并将生成的 public 目录中的内容推送至 gh-pages 分支。\n在 blog 目录下新建 .github/workflows/gh-pages.yml 文件，文件内容如下。\nname: Github Pages on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Read .env id: hugo-version run: |. ./.env echo \u0026#34;::set-output name=HUGO_VERSION::${HUGO_VERSION}\u0026#34; - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;${{ steps.hugo-version.outputs.HUGO_VERSION }}\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.ACTIONS_TOKEN }} publish_branch: gh-pages publish_dir: ./public cname: www.shisanshiji.com user_name: \u0026#39;jugggao\u0026#39; user_email: \u0026#39;jugg.gao@qq.com\u0026#39; commit_message: ${{ github.event.head_commit.message }} enable_jekyll: false allow_empty_commit: true 此 Github Action 的动作如下：\n 通过 on.push.branches: ['main'] 指定了只有在推送至 main 分支时才会触发此 Action。 Checkout 阶段进行拉取代码，包括子模块中的代码（上面你克隆的主题代码仓库）。 Read .env 阶段会读取当前目录中的 .env 文件中的 HUGO_VERSION 的值，并配置为当前 ACTION 的环境变量。 Setup hugo 阶段会根据刚才配置的 HUGO_VERSION 的版本号配置 Hugo 环境。 Build 阶段会进行源码构建，构建的静态网站存储在 public 目录。 Deploy 阶段通过 secrets.ACTIONS_TOKEN 值进行认证，认证过后再将构建的 public 目录中的内容推送到 gh-pages 分支。  注意\n 需要替换 Deploy 阶段 with.user_name 与 with.user_email 的值。 如果你不希望每次都拉取应用主题仓库的最新代码，可以将 Checkout 阶段的 with.submodules 的值改为 False。 如果你使用 Github 提供的默认域名，则需要删除 with.cname 这一行配置。   你会发现在推送之前还需要两个操作：\n 创建 .env 文件，并指定 Hugo 版本。 生成 Github Token 并在 blog 仓库中配置。  首先，在 blog 目录下 .env 文件，内容如下所示。你还可以将版本替换为你本地正在使用的版本以避免不确定的错误。\nHUGO_VERSION=0.89.1 然后，在 Github 中点击用户头像依次点击「Settings」 -\u0026gt; 「Developer settings」-\u0026gt;「Personal access tokens」-\u0026gt;「Generate new token」 来生成 Token。\n点击查看生成 Token 配置页面  最后，回到你的 blog 仓库，点击「Settings」-\u0026gt;「Secrets」-\u0026gt;「New repository secret」 添加刚才生成的 Token。名称需要和 gh-pages.yml 中引用的 ACTIONS_TOKEN 环境变量保持一致。\n点击查看添加 Token 配置页面  准备完成之后，将新添加的文件推送至远程仓库。\n$ git add . $ git commit -m \u0026#34;添加 Github Action 相关文件\u0026#34; $ git push -u origin main 这时，你可以在 blog 仓库页面中点击「Actions」观察 Wrokflows 的运行状况。如果发生错误，可以对每个阶段进行展开查看运行日志进行排查。\n点击查看 Github Action 运行页面  Github Action 运行成功后，你会发现在 blog 仓库中新增了 gh-pages 分支，分支的内容正是之前我们手动构建时生成的 public 目录下静态网站。\n配置 Github Pages 在 blog 仓库页面中依次点击「Settings」-\u0026gt;「Pages」。确定你开启了 Pages 功能并一切正常。\n点击查看 Github Pages 配置页面  如果你之前事前准备了自定义域名，可以参考 Github 官方文档 说明一步步配置自定义域名。配置完成后，可以勾选「Enforce HTTPS」 选项并由 Github 自动为你的域名颁发 SSL 证书。\n验证博客访问 最后，在浏览器中输入你的博客网址来验收成果。\n参考  GitHub Pages Documentation Hugo+GitHub Action+Github Pages搭建个人博客 Ace documentation  "},{"uri":"https://www.shisanshiji.com/devops/tekton/tekton-practice-task/","title":"Tekton 实践：安装","tags":null,"description":"","content":""},{"uri":"https://www.shisanshiji.com/operation-guide/","title":"操作指南","tags":null,"description":"","content":"好记性不如烂笔头。 Hugo\u0026amp;Github Action\u0026amp;Github Pages 搭建个人博客   使用 Keycloak 与 Oauth2-Proxy 认证 Kubernetes 应用    "},{"uri":"https://www.shisanshiji.com/troubleshooting/","title":"问题排查","tags":null,"description":"","content":" 宝剑锋从磨砺出。 Elasticsearch 问题排查    "},{"uri":"https://www.shisanshiji.com/devops/","title":"DevOps","tags":null,"description":"","content":"DevOps。 DevOps    "},{"uri":"https://www.shisanshiji.com/devops/tekton/","title":"DevOps","tags":null,"description":"","content":"Tekton CICD Tekton 实践：安装    "},{"uri":"https://www.shisanshiji.com/operation-guide/kubernetes-%E5%BA%94%E7%94%A8%E4%BD%BF%E7%94%A8-keycloak-%E4%B8%8E-oauth2-proxy-%E8%BF%9B%E8%A1%8C%E8%AE%A4%E8%AF%81/","title":"使用 Keycloak 与 Oauth2-Proxy 认证 Kubernetes 应用","tags":null,"description":"","content":"安装 Keycloak-Operator # 1. 创建 keycloak 命名空间 kubectl create ns keycloak # 2. 创建 serviceaccount kubectl -n keycloak apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/service_account.yaml # 3. 创建 Role 和 Rolebinding（Namspace 范围） kubectl -n keycloak apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/role.yaml kubectl -n keycloak apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/role_binding.yaml # 这里创建的 keycloak-operator 为 namespace 范围，operator 只作用于 keycloak 这个 namespace 下。 # 如果需要 cluster 范围，需要改用 ClusterRole 和 ClusterRoleBinding # kubectl -n keycloak apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/cluster_roles/cluster_role.yaml # kubectl -n keycloak apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/cluster_roles/cluster_role_binding.yaml # 3. 安装 crds kubectl apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/crds/keycloak.org_keycloaks_crd.yaml kubectl apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/crds/keycloak.org_keycloakusers_crd.yaml kubectl apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/crds/keycloak.org_keycloakrealms_crd.yaml kubectl apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/crds/keycloak.org_keycloakclients_crd.yaml kubectl apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/crds/keycloak.org_keycloakbackups_crd.yaml # 安装 keycloak-operator kubectl -n keycloak apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/operator.yaml "},{"uri":"https://www.shisanshiji.com/categories/","title":"Categories","tags":null,"description":"","content":""},{"uri":"https://www.shisanshiji.com/tags/","title":"Tags","tags":null,"description":"","content":""},{"uri":"https://www.shisanshiji.com/","title":"十三时记","tags":null,"description":"","content":"无他，惟手熟尔。 分类   操作指南  软件配置、工具使用等      问题排查  实际环境遇见的问题解决步骤    "}]