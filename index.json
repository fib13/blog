[{"uri":"https://www.shisanshiji.com/troubleshooting/elasticsearch-troubleshooting/","title":"Elasticsearch 问题排查","tags":null,"description":"","content":"问题列表如下：\n 集群中包含未分配的副本导致集群变为 Red 状态  集群中包含未分配的副本导致集群变为 Red 状态 查看集群状态信息 首先确定原因。\n查看整体健康信息 $ curl -u \u0026#39;elastic:password\u0026#39; \u0026#39;http://127.0.0.1:9200/_cluster/health?pretty\u0026#39; { \u0026#34;cluster_name\u0026#34; : \u0026#34;elasticsearch\u0026#34;, \u0026#34;status\u0026#34; : \u0026#34;red\u0026#34;, \u0026#34;timed_out\u0026#34; : false, \u0026#34;number_of_nodes\u0026#34; : 1, \u0026#34;number_of_data_nodes\u0026#34; : 1, \u0026#34;active_primary_shards\u0026#34; : 69, \u0026#34;active_shards\u0026#34; : 69, \u0026#34;relocating_shards\u0026#34; : 0, \u0026#34;initializing_shards\u0026#34; : 0, \u0026#34;unassigned_shards\u0026#34; : 1, \u0026#34;delayed_unassigned_shards\u0026#34; : 0, \u0026#34;number_of_pending_tasks\u0026#34; : 0, \u0026#34;number_of_in_flight_fetch\u0026#34; : 0, \u0026#34;task_max_waiting_in_queue_millis\u0026#34; : 0, \u0026#34;active_shards_percent_as_number\u0026#34; : 98.57142857142858 } 主要关注其中的 unassigned_shards 指标，其代表已经在集群状态中存在的分片，但是实际在集群里又找不着。通常未分配分片的来源是未分配的副本。比如，一个有 5 分片和 1 副本的索引，在单节点集群上，就会有 5 个未分配副本分片。如果你的集群是 red 状态，也会长期保有未分配分片（因为缺少主分片）。其他指标解释：\n  initializing_shards 是刚刚创建的分片的个数。比如，当你刚创建第一个索引，分片都会短暂的处于 initializing 状态。这通常会是一个临时事件，分片不应该长期停留在 initializing 状态。你还可能在节点刚重启的时候看到 initializing 分片：当分片从磁盘上加载后，它们会从 initializing 状态开始。\n  number_of_nodes 和 number_of_data_nodes：可由字面意思理解。\n  active_primary_shards：指出你集群中的主分片数量。这是涵盖了所有索引的汇总值。\n  active_shards：所有索引的所有分片的汇总值，即包括副本分片。\n  relocating_shards：显示当前正在从一个节点迁往其他节点的分片的数量。通常来说应该是 0，不过在 Elasticsearch 发现集群不太均衡时，该值会上涨。比如说：添加了一个新节点，或者下线了一个节点。\n  active_shards_percent_as_number：活跃分片数占总分片数比例。\n  查看每个索引的健康信息 我们还可以通过 level 参数查看更详细的信息：\ncurl -u elastic:password \u0026#39;http://127.0.0.1:9200/_cluster/health?pretty=true\u0026amp;level=indices\u0026#39; { \u0026#34;cluster_name\u0026#34; : \u0026#34;elasticsearch\u0026#34;, \u0026#34;status\u0026#34; : \u0026#34;red\u0026#34;, \u0026#34;timed_out\u0026#34; : false, \u0026#34;number_of_nodes\u0026#34; : 1, \u0026#34;number_of_data_nodes\u0026#34; : 1, \u0026#34;active_primary_shards\u0026#34; : 69, \u0026#34;active_shards\u0026#34; : 69, \u0026#34;relocating_shards\u0026#34; : 0, \u0026#34;initializing_shards\u0026#34; : 0, \u0026#34;unassigned_shards\u0026#34; : 2, \u0026#34;delayed_unassigned_shards\u0026#34; : 0, \u0026#34;number_of_pending_tasks\u0026#34; : 0, \u0026#34;number_of_in_flight_fetch\u0026#34; : 0, \u0026#34;task_max_waiting_in_queue_millis\u0026#34; : 0, \u0026#34;active_shards_percent_as_number\u0026#34; : 97.1830985915493, \u0026#34;indices\u0026#34; : { ... \u0026#34;kubernetes-2021.08.13\u0026#34; : { \u0026#34;status\u0026#34; : \u0026#34;green\u0026#34;, \u0026#34;number_of_shards\u0026#34; : 1, \u0026#34;number_of_replicas\u0026#34; : 0, \u0026#34;active_primary_shards\u0026#34; : 1, \u0026#34;active_shards\u0026#34; : 1, \u0026#34;relocating_shards\u0026#34; : 0, \u0026#34;initializing_shards\u0026#34; : 0, \u0026#34;unassigned_shards\u0026#34; : 1 }, ... } 添加 level=indices 参数会在集群健康信息里添加一个索引清单，以及有关每个索引的细节（状态、分片数、未分配分片数等等），一旦我们询问要索引的输出，哪个索引有问题立马就很清楚了：kubernetes-2021.08.13。\n查看每个索引的每个分片的健康信息 我们可以更细致的输出索引的每个分片的健康信息，通过添加参数 level=shards 获取。\ncurl -u \u0026#39;elastic:password\u0026#39; \u0026#39;http://127.0.0.1:9200/_cluster/health?pretty=true\u0026amp;level=shards\u0026#39; 通过添加 level=indices 参数可以列出每个索引里每个分片的状态和位置。这个输出有时候很有用，但是由于太过详细会比较难用。\n查看未分配分片的索引及原因 curl -u \u0026#39;elastic:password\u0026#39; \u0026#39;http://127.0.0.1:9200/_cat/shards?v\u0026amp;h=index,shard,prirep,state,unassigned.reason\u0026#39; index shard prirep state unassigned.reason .apm-custom-link 0 p STARTED ... kubernetes-2021.10.10 0 p STARTED kubernetes-2021.11.03 0 p UNASSIGNED CLUSTER_RECOVERED kubernetes-2021.08.19 0 p STARTED ... unassigned.reason 值说明：\n INDEX_CREATED: 由于创建索引的 API 导致未分配。 CLUSTER_RECOVERED: 由于完全集群恢复导致未分配。 INDEX_REOPENED: 由于打开 open 或关闭 close 一个索引导致未分配。 DANGLING_INDEX_IMPORTED: 由于导入 dangling 索引的结果导致未分配。 NEW_INDEX_RESTORED: 由于恢复到新索引导致未分配。 EXISTING_INDEX_RESTORED: 由于恢复到已关闭的索引导致未分配。 REPLICA_ADDED: 由于显式添加副本分片导致未分配。 ALLOCATION_FAILED: 由于分片分配失败导致未分配。 NODE_LEFT: 由于承载该分片的节点离开集群导致未分配。 REINITIALIZED: 由于当分片从开始移动到初始化时导致未分配（例如，使用Shadow 副本分片）。 REROUTE_CANCELLED: 作为显式取消重新路由命令的结果取消分配。 REALLOCATED_REPLICA: 确定更好的副本位置被标定使用，导致现有的副本分配被取消，出现未分配。  解决方法 由两种方法可解决，任选其中一种即可。\n手动分配 curl -u \u0026#39;elastic:password\u0026#39; -H \u0026#34;Content-Type: application/json\u0026#34; \u0026#39;http://127.0.0.1:9200/_cluster/reroute\u0026#39; -d \u0026#39;{ \u0026#34;commands\u0026#34;: [{ \u0026#34;allocate\u0026#34;: { \u0026#34;index\u0026#34;: \u0026#34;\u0026lt;索引名称\u0026gt;\u0026#34;, \u0026#34;shard\u0026#34;: \u0026lt;分片编号\u0026gt;, \u0026#34;node\u0026#34;: \u0026#34;\u0026lt;节点 ID\u0026gt;\u0026#34;, \u0026#34;allow_primary\u0026#34;: true } }] }\u0026#39; 批处理脚本：\n#!/bin/bash array=( node1 node2 node3 ) node_counter=0 length=${#array[@]} IFS=$\u0026#39;\\n\u0026#39; for line in $(curl -s \u0026#39;http://127.0.0.1:9200/_cat/shards\u0026#39;| fgrep UNASSIGNED); do INDEX=$(echo $line | (awk \u0026#39;{print $1}\u0026#39;)) SHARD=$(echo $line | (awk \u0026#39;{print $2}\u0026#39;)) NODE=${array[$node_counter]} echo $NODE curl -XPOST \u0026#39;http://127.0.0.1:9200/_cluster/reroute\u0026#39; -d \u0026#39;{ \u0026#34;commands\u0026#34;: [ { \u0026#34;allocate\u0026#34;: { \u0026#34;index\u0026#34;: \u0026#34;\u0026#39;$INDEX\u0026#39;\u0026#34;, \u0026#34;shard\u0026#34;: \u0026#39;$SHARD\u0026#39;, \u0026#34;node\u0026#34;: \u0026#34;\u0026#39;$NODE\u0026#39;\u0026#34;, \u0026#34;allow_primary\u0026#34;: true } } ] }\u0026#39; node_counter=$(((node_counter)%length +1)) done 重新建立副本 如果在上面的命令执行输出结果中，假如所有的 primary shards 都是正常的，所有 replica shards 有问题，有一种快速恢复的方法，就是强制删除掉 replica shards，让 Elasticsearch 自主重新生成。\n首先先将出问题的索引的副本为 0：\ncurl -u \u0026#39;elastic:password\u0026#39; -H \u0026#34;Content-Type: application/json\u0026#34; -X PUT \u0026#39;http://127.0.0.1:9200/\u0026lt;索引名称\u0026gt;/_settings\u0026#39; -d \u0026#39;{ \u0026#34;index\u0026#34;: {\u0026#34;number_of_replicas\u0026#34;: 0}}\u0026#39; 然后观察集群状态，最后通过命令在恢复期索引副本数据：\ncurl -u \u0026#39;elastic:password\u0026#39; -H \u0026#34;Content-Type: application/json\u0026#34; -X PUT \u0026#39;http://127.0.0.1:9200/\u0026lt;索引名称\u0026gt;/_settings\u0026#39; -d \u0026#39;{ \u0026#34;index\u0026#34;: {\u0026#34;number_of_replicas\u0026#34;: 1}}\u0026#39; 等待节点自动分配后，集群成功恢复成 green。\n"},{"uri":"https://www.shisanshiji.com/learning-notes/golang/go-install/","title":"Go 安装","tags":null,"description":"","content":"开发环境 使用 VSCode 编辑器。\n在 Debian 11 远程开发环境上开发。\n安装 wget https://golang.google.cn/dl/go1.17.4.linux-amd64.tar.gz rm -rf /usr/local/go \u0026amp;\u0026amp; tar -C /usr/local -xzf go1.17.4.linux-amd64.tar.gz echo -e \u0026#34;\\nexport PATH=\\$PATH:/usr/local/go/bin:\\$GOPATH/bin\u0026#34; | tee -a ~/.profile source ~/.profile go version 环境 go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.io,direct 编辑器 安装 vscode-go 插件。\n再安装开发工具。\n语法检测 go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest "},{"uri":"https://www.shisanshiji.com/learning-notes/golang/","title":"Golang 学习笔记","tags":null,"description":"","content":" Go 安装   Golang 教程    "},{"uri":"https://www.shisanshiji.com/operation-guide/hugo-githubactiongithub-pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","title":"Hugo\u0026Github Action\u0026Github Pages 搭建个人博客","tags":null,"description":"","content":"介绍 大致的流程如下：\n 首先通过 Hugo 生成博客网站，并进行配置、添加内容。 然后在 Github 上创建一个 blog 仓库，并将博客源码推送到 blog 仓库的 main 分支。 接着使用 Github Action 构建出静态网站，并自动推送至 gh-pages 分支。 最后配置 Github Pages 绑定 gh-pages 分支上的内容，就可以使用生成或配置的域名进行访问。  先决条件 准备 Git（必须） 如未安装 Git，参考 Git 安装指南 进行安装。\n安装完成后，可以通过 git version 命令进行验证。\n$ git version git version 2.29.2.windows.2 如果你是第一次安装，则需要初始化 Git 用户信息。将以下内容中邮箱和名字替换为合适的值并运行。\n$ git config --global user.email \u0026#34;you@example.com\u0026#34; $ git config --global user.name \u0026#34;Your Name\u0026#34; 准备 Github 仓库（必须） 在 Github 上创建 blog 仓库，你也可以选择其他合适的名称作为博客的仓库。\n点击查看配置仓库页面  准备 Hugo（必须） 如未安装 Hugo，参考 Hugo 安装指南 进行安装。\n安装完成后，可以通过 hugo version 命令进行验证。\n$ hugo version hugo v0.89.1-B6A4AE4A+extended windows/amd64 BuildDate=2021-11-05T15:44:32Z VendorInfo=gohugoio 准备域名（可选） 部署至 Github 上以后，默认会使用 \u0026lt;username\u0026gt;.github.io 域名访问你的博客。如果你想使用自己的域名，需要购买一个域名备用。可在腾讯云、阿里云或其他域名供应商购买。\n创建博客 生成博客 使用 hugo new site blog 命令来生成博客源码仓库。\n$ hugo new site blog Congratulations! Your new Hugo site is created in C:\\Users\\Peng.Gao\\Desktop\\Blog\\blog. Just a few more steps and you are ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; command. 2. Perhaps you want to add some content. You can add single files with \u0026#34;hugo new \u0026lt;SECTIONNAME\u0026gt;\\\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 3. Start the built-in live server via \u0026#34;hugo server\u0026#34;. Visit https://gohugo.io/ for quickstart guide and full documentation. 切换当前目录至 blog 目录，可以使用 tree 命令查看目录的结构。\n$ cd blog $ tree -L 1 . |-- archetypes |-- config.toml |-- content |-- data |-- layouts |-- static `-- themes 6 directories, 1 file 应用主题 你可以选择一个喜欢的主题应用于你的博客，此博客使用的主题为 Ace documentation。\n$ git submodule add https://github.com/vantagedesign/ace-documentation themes/ace-documentation Cloning into \u0026#39;C:/Users/Peng.Gao/Desktop/Blog/docs/themes/ace-documentation\u0026#39;... remote: Enumerating objects: 555, done. remote: Counting objects: 100% (139/139), done. remote: Compressing objects: 100% (90/90), done. remote: Total 555 (delta 57), reused 88 (delta 35), pack-reused 416 Receiving objects: 100% (555/555), 2.15 MiB | 683.00 KiB/s, done. Resolving deltas: 100% (191/191), done. warning: LF will be replaced by CRLF in .gitmodules. The file will have its original line endings in your working directory 接下来需要根据你应用主题的教程来配置 config.toml 文件，主题配置教程在刚才你寻找的主题页面上查看。\n还可以根据主题的样例去新添加一些内容，在此不过多说明。\n构建博客 配置完成后，在 blog 目录下可以使用 hugo server 启动 Web 服务器。Hugo 会构建站点内容到内存中并在检测到文件更改后重新渲染，方便在开发环境中实时预览对站点所做的更改。\n$ hugo server Start building sites … hugo v0.89.1-B6A4AE4A+extended windows/amd64 BuildDate=2021-11-05T15:44:32Z VendorInfo=gohugoio | EN -------------------+----- Pages | 18 Paginator pages | 0 Non-page files | 0 Static files | 26 Processed images | 0 Aliases | 0 Sitemaps | 1 Cleaned | 0 Built in 173 ms Watching for changes in C:\\Users\\Peng.Gao\\Desktop\\Blog\\docs\\{archetypes,content,data,layouts,static,themes} Watching for config changes in C:\\Users\\Peng.Gao\\Desktop\\Blog\\docs\\config.toml Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 如果你在远端开发，可以使用 hugo server --bind 0.0.0.0 配置绑定的网卡。 如果你想更换端口号，也可以使用 hugo server -p 80 配置监听端口号。 如果在调试阶段需要输出处于草稿状态的文章（通过在文章注释中添加 draft: true 配置），则需要使用 hugo server -D 来渲染草稿。\n想了解更多的选项，运行 hugo --help 来查看它们的说明。\n预览效果满意后，可以使用 hugo 命令进行构建。\n$ hugo Start building sites … hugo v0.89.1-B6A4AE4A+extended windows/amd64 BuildDate=2021-11-05T15:44:32Z VendorInfo=gohugoio | EN -------------------+----- Pages | 18 Paginator pages | 0 Non-page files | 0 Static files | 26 Processed images | 0 Aliases | 0 Sitemaps | 1 Cleaned | 0 Total in 200 ms 构建完成后，再观察 blog 目录，会发现出现了新的目录为 public，这个目录就是我们构建出来的静态网站，通过 tree 命令观察 public，就是一个静态页面的结构。\n$ tree -L 1 public/ public/ |-- 404.html |-- categories |-- css |-- img |-- index.html |-- index.json |-- js |-- learn-notes |-- lib |-- operation-guide |-- plugins |-- sitemap.xml |-- tags `-- webfonts 10 directories, 4 files 部署至 Github 推送博客源码 现在，我们就可以将 blog 目录中的源码推送至 Github 远程仓库的 main 分支了。\n但在推送前，应该还需要忽略一些文件。思考一下介绍时所描述的大致步骤，你的博客源码是存储在 main 分支的，经过自动构建才会最新生成的 public 文件中的内容推送至 gh-pages 分支，我们并不需要将 public 目录推送至 main 分支，因此需要忽略 public 目录。此外还可能需要忽略一些其他的文件或目录，比如启动 Web 服务时所生成的 .hugo_build.lock 文件和 resources 目录，或者由编辑器产生的本地配置目录及文件。以下是我在 .gitignore 文件中忽略的内容，仅供参考。\n*.lock *.vscode *.log *.idea resources/ public/ 添加完 .gitignore 文件以后，你可以添加 Github 远程仓库并推送至 main 分支。\n$ git init $ git add . $ git commit -m \u0026#34;init\u0026#34; $ git branch -M main $ git remote add origin https://github.com/jugggao/blog.git $ git push -u origin main  注意\n需要更换远程仓库 URL 中的名称为你的 Github 用户名。  使用 Github Action 自动构建 我们将博客源码上传至 main 分支之后，就需要通过 Github Action 进行自动构建了，并将生成的 public 目录中的内容推送至 gh-pages 分支。\n在 blog 目录下新建 .github/workflows/gh-pages.yml 文件，文件内容如下。\nname: Github Pages on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Read .env id: hugo-version run: |. ./.env echo \u0026#34;::set-output name=HUGO_VERSION::${HUGO_VERSION}\u0026#34; - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;${{ steps.hugo-version.outputs.HUGO_VERSION }}\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.ACTIONS_TOKEN }} publish_branch: gh-pages publish_dir: ./public cname: www.shisanshiji.com user_name: \u0026#39;jugggao\u0026#39; user_email: \u0026#39;jugg.gao@qq.com\u0026#39; commit_message: ${{ github.event.head_commit.message }} enable_jekyll: false allow_empty_commit: true 此 Github Action 的动作如下：\n 通过 on.push.branches: ['main'] 指定了只有在推送至 main 分支时才会触发此 Action。 Checkout 阶段进行拉取代码，包括子模块中的代码（上面你克隆的主题代码仓库）。 Read .env 阶段会读取当前目录中的 .env 文件中的 HUGO_VERSION 的值，并配置为当前 ACTION 的环境变量。 Setup hugo 阶段会根据刚才配置的 HUGO_VERSION 的版本号配置 Hugo 环境。 Build 阶段会进行源码构建，构建的静态网站存储在 public 目录。 Deploy 阶段通过 secrets.ACTIONS_TOKEN 值进行认证，认证过后再将构建的 public 目录中的内容推送到 gh-pages 分支。  注意\n 需要替换 Deploy 阶段 with.user_name 与 with.user_email 的值。 如果你不希望每次都拉取应用主题仓库的最新代码，可以将 Checkout 阶段的 with.submodules 的值改为 False。 如果你使用 Github 提供的默认域名，则需要删除 with.cname 这一行配置。   你会发现在推送之前还需要两个操作：\n 创建 .env 文件，并指定 Hugo 版本。 生成 Github Token 并在 blog 仓库中配置。  首先，在 blog 目录下 .env 文件，内容如下所示。你还可以将版本替换为你本地正在使用的版本以避免不确定的错误。\nHUGO_VERSION=0.89.1 然后，在 Github 中点击用户头像依次点击「Settings」 -\u0026gt; 「Developer settings」-\u0026gt;「Personal access tokens」-\u0026gt;「Generate new token」 来生成 Token。\n点击查看生成 Token 配置页面  最后，回到你的 blog 仓库，点击「Settings」-\u0026gt;「Secrets」-\u0026gt;「New repository secret」 添加刚才生成的 Token。名称需要和 gh-pages.yml 中引用的 ACTIONS_TOKEN 环境变量保持一致。\n点击查看添加 Token 配置页面  准备完成之后，将新添加的文件推送至远程仓库。\n$ git add . $ git commit -m \u0026#34;添加 Github Action 相关文件\u0026#34; $ git push -u origin main 这时，你可以在 blog 仓库页面中点击「Actions」观察 Wrokflows 的运行状况。如果发生错误，可以对每个阶段进行展开查看运行日志进行排查。\n点击查看 Github Action 运行页面  Github Action 运行成功后，你会发现在 blog 仓库中新增了 gh-pages 分支，分支的内容正是之前我们手动构建时生成的 public 目录下静态网站。\n配置 Github Pages 在 blog 仓库页面中依次点击「Settings」-\u0026gt;「Pages」。确定你开启了 Pages 功能并一切正常。\n点击查看 Github Pages 配置页面  如果你之前事前准备了自定义域名，可以参考 Github 官方文档 说明一步步配置自定义域名。配置完成后，可以勾选「Enforce HTTPS」 选项并由 Github 自动为你的域名颁发 SSL 证书。\n验证博客访问 最后，在浏览器中输入你的博客网址来验收成果。\n参考  GitHub Pages Documentation Hugo+GitHub Action+Github Pages搭建个人博客 Ace documentation  "},{"uri":"https://www.shisanshiji.com/devops/tekton/tekton-practice-task/","title":"Tekton 实践：安装","tags":null,"description":"","content":""},{"uri":"https://www.shisanshiji.com/learning-notes/","title":"学习笔记","tags":null,"description":"","content":"入门到放弃或从入门到入土。 Golang 学习笔记    "},{"uri":"https://www.shisanshiji.com/operation-guide/","title":"操作指南","tags":null,"description":"","content":"好记性不如烂笔头。 Hugo\u0026amp;Github Action\u0026amp;Github Pages 搭建个人博客   使用 Keycloak 与 Oauth2-Proxy 认证 Kubernetes 应用    "},{"uri":"https://www.shisanshiji.com/learning-notes/golang/go-tutorial/","title":"Golang 教程","tags":null,"description":"","content":"教程：开始 mkdir hello cd hello go mod init example/hello vim hello.go package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } go run . 引用外部包。\npackage main import \u0026#34;fmt\u0026#34; import \u0026#34;rsc.io/quote\u0026#34; func main() { fmt.Println(quote.Go()) } 下载外部包，并在 go.mod 中添加依赖以及生成认证文件 go.sum。\ngo mod tidy 教程：创建一个 Go 模块 创建模块 mkdir greetings cd greetings/ go mod init example.com/greetings vim greetings.go package greetings import \u0026#34;fmt\u0026#34; // Hello returns a greeting for the named person func Hello(name string) string { // Return a greeting that embeds the the in a message.  message := fmt.Sprintf(\u0026#34;Hi, %v. Welcome!\u0026#34;, name) return message } 调用其他模块 此时目录结构为：\n. ├── greetings └── hello cd hello rm -rf * go mod init example.com/hello vim hello.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;example.com/greetings\u0026#34; ) func main() { // Get a greeting message and print it. \tmessage := greetings.Hello(\u0026#34;Gladys\u0026#34;) fmt.Println(message) } 重定向 Go 模块路径并添加依赖：\ngo mod edit -replace example.com/greetings=../greetings go mod tidy 运行：\ngo run . 错误处理 greetings.go：\npackage greetings import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) // Hello returns a greeting for the named person func Hello(name string) (string, error) { // If no name was given, return an error with a message. \tif name == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;empty name\u0026#34;) } // If a name was received, Return a greeting that embeds the the \t// in a message. \tmessage := fmt.Sprintf(\u0026#34;Hi, %v. Welcome!\u0026#34;, name) return message, nil } hello.go：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;example.com/greetings\u0026#34; ) func main() { // Set properties of the predefined Logger, including the log \t// entry prefix and a flag to disable printing the time, source \t// file, and line number. \tlog.SetPrefix(\u0026#34;greetings: \u0026#34;) log.SetFlags(0) // Request a greeting message. \tmessage, err := greetings.Hello(\u0026#34;\u0026#34;) // If an error was returned, print it to the console and exit the program. \tif err != nil { log.Fatal(err) } // If no error was returned, print the returned message to the massage. \tfmt.Println(message) } 随机问候 greetings.go:\npackage greetings import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) // Hello returns a greeting for the named person func Hello(name string) (string, error) { // If no name was given, return an error with a message. \tif name == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;empty name\u0026#34;) } // If a name was received, Return a greeting that embeds the the in a \t// message. \tmessage := fmt.Sprintf(randomFormat(), name) return message, nil } // init sets initial values for variables used in the fuction. func init() { rand.Seed(time.Now().UnixNano()) } // randomFormat returns one of a set of greeting messages. The returned message // is selected at random. func randomFormat() string { // A slice of message formats. \tformats := []string{ \u0026#34;Hi, %v. Welcome!\u0026#34;, \u0026#34;Great to see you, %v!\u0026#34;, \u0026#34;Hail, %v! Well met!\u0026#34;, } // Return a randomly selected message format by specifying a random index \t// for the slice of formats. \treturn formats[rand.Intn(len(formats))] } hello.go：\nmessage, err := greetings.Hello(\u0026#34;Gladys\u0026#34;) 多人问候 greetings.go：\npackage greetings import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) // Hello returns a greeting for the named person func Hello(name string) (string, error) { // If no name was given, return an error with a message. \tif name == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;empty name\u0026#34;) } // If a name was received, Return a greeting that embeds the the in a \t// message. \tmessage := fmt.Sprintf(randomFormat(), name) return message, nil } // Hellos returns a map that associates each of the named people with a greeting // message. func Hellos(names []string) (map[string]string, error) { // A map to associate names with messages. \tmessages := make(map[string]string) // Loop through the received slice of names, calling the Hello function to \t// get a message for each name. \tfor _, name := range names { message, err := Hello(name) if err != nil { return nil, err } // In the map, associate the retrieved message with the name. \tmessages[name] = message } return messages, nil } hello.go\nfunc main() { // Set properties of the predefined Logger, including the log \t// entry prefix and a flag to disable printing the time, source \t// file, and line number. \tlog.SetPrefix(\u0026#34;greetings: \u0026#34;) log.SetFlags(0) // A slice of names. \tnames := []string{\u0026#34;Gladys\u0026#34;, \u0026#34;Samantha\u0026#34;, \u0026#34;Darrin\u0026#34;} // Request greeting messages for the names. \tmessages, err := greetings.Hellos(names) // If an error was returned, print it to the console and exit the program. \tif err != nil { log.Fatal(err) } // If no error was returned, print the returned message to the massage. \tfmt.Println(messages) } 测试 greetings_test.go：\npackage greetings import ( \u0026#34;regexp\u0026#34; \u0026#34;testing\u0026#34; ) // TestHelloName calls greetings.Hello with a name, cheking for a vaild return // value. func TestHelloName(t *testing.T) { name := \u0026#34;Gladys\u0026#34; want := regexp.MustCompile(`\\b` + name + `\\b`) msg, err := Hello(\u0026#34;Gladys\u0026#34;) if !want.MatchString(msg) || err != nil { t.Fatalf(`Hello(\u0026#34;Gladys\u0026#34;) = %q, %v, want match for %#q, nil`, msg, err, want) } } // TestHelloEmpty calls greetings.Hello with an empty string, checking for an // error. func TestHelloEmpty(t *testing.T) { msg, err := Hello(\u0026#34;\u0026#34;) if msg != \u0026#34;\u0026#34; || err == nil { t.Fatalf(`Hello(\u0026#34;\u0026#34;) = %q, %v, want \u0026#34;\u0026#34;, error`, msg, err) } } 编译安装 编译：\ngo build ./hello 安装：\n# 显示安装目录 go list -f \u0026#39;{{ .Target }}\u0026#39; # 配置环境变量 export PATH=$PATH:/path/to/your/install/directory # 安装 go install # 运行 hello 教程：访问关系型数据库 准备 安装 MySQL：\ndocker run -itd --name mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 mysql:5.7 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci mkdir data-access cd data-access go mod init example/data-access 初始化数据库 docker exec -ti mysql mysql -u root -p123456 创建数据库：\ncreate database recordings; create-tables.sql：\nDROP TABLE IF EXISTS album; CREATE TABLE album ( id\tINT AUTO_INCREMENT NOT NULL, title\tVARCHAR(128) NOT NULL, artist\tVARCHAR(128) NOT NULL, price\tDECIMAL(5,2) NOT NULL, PRIMARY KEY (`id`) ); INSERT INTO album (title, artist, price) VALUES (\u0026#39;Blue Train\u0026#39;, \u0026#39;John Coltrane\u0026#39;, 56.99), (\u0026#39;Giant Steps\u0026#39;, \u0026#39;John Coltrane\u0026#39;, 63.99), (\u0026#39;Jeru\u0026#39;, \u0026#39;Gerry Mulligan\u0026#39;, 17.99), (\u0026#39;Sarah Vaughan\u0026#39;, \u0026#39;Sarah Vaughan\u0026#39;, 34.98); 初始化数据：\ndocker exec -ti mysql mysql -uroot -p123456 recordings -e \u0026#34;source /tmp/create-tables.sql mysql\u0026gt; select * from album; +----+---------------+----------------+-------+ | id | title | artist | price | +----+---------------+----------------+-------+ | 1 | Blue Train | John Coltrane | 56.99 | | 2 | Giant Steps | John Coltrane | 63.99 | | 3 | Jeru | Gerry Mulligan | 17.99 | | 4 | Sarah Vaughan | Sarah Vaughan | 34.98 | +----+---------------+----------------+-------+ 获取数据库句柄并链接 main.go\npackage main import ( \u0026#34;database/sql\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/go-sql-driver/mysql\u0026#34; ) var db *sql.DB func main() { // Capture connection properties. \tcfg := mysql.Config{ User: os.Getenv(\u0026#34;DBUSER\u0026#34;), Passwd: os.Getenv(\u0026#34;DBPASS\u0026#34;), Net: \u0026#34;tcp\u0026#34;, Addr: \u0026#34;127.0.0.1:3306\u0026#34;, DBName: \u0026#34;recordings\u0026#34;, AllowNativePasswords: true, } // Get a database handle. \tvar err error db, err = sql.Open(\u0026#34;mysql\u0026#34;, cfg.FormatDSN()) if err != nil { log.Fatal(err) } pingErr := db.Ping() if pingErr != nil { log.Fatal(pingErr) } fmt.Println(\u0026#34;Connected!\u0026#34;) }  sql.DB 表示一个连接池。 sql.Open 的第一个参数是驱动名称。 cfg.FormatDSN() 将配置转换为 \u0026ldquo;User:Passwd@tcp(127.0.0.1:3306)/recordings\u0026rdquo;。 db.Ping() 检查数据库连通性。  go get . go run . 查询多行 package main import ( \u0026#34;database/sql\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/go-sql-driver/mysql\u0026#34; ) var db *sql.DB type Album struct { ID int64 Title string Artist string Price float32 } func main() { // Capture connection properties. \tcfg := mysql.Config{ User: os.Getenv(\u0026#34;DBUSER\u0026#34;), Passwd: os.Getenv(\u0026#34;DBPASS\u0026#34;), Net: \u0026#34;tcp\u0026#34;, Addr: \u0026#34;127.0.0.1:3306\u0026#34;, DBName: \u0026#34;recordings\u0026#34;, AllowNativePasswords: true, } // Get a database handle. \tvar err error db, err = sql.Open(\u0026#34;mysql\u0026#34;, cfg.FormatDSN()) if err != nil { log.Fatal(err) } pingErr := db.Ping() if pingErr != nil { log.Fatal(pingErr) } fmt.Println(\u0026#34;Connected!\u0026#34;) albums, err := albumByArtist(\u0026#34;John Coltrane\u0026#34;) if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;Albums found: %v\\n\u0026#34;, albums) } // albumByArtist queries for album that have the specified artist name. func albumByArtist(name string) ([]Album, error) { // An album slice to hold data from returned rows. \tvar albums []Album rows, err := db.Query(\u0026#34;SELECT * FROM album WHERE artist = ?\u0026#34;, name) if err != nil { return nil, fmt.Errorf(\u0026#34;albumByArtist %q: %v\u0026#34;, name, err) } defer rows.Close() // Loop through rows, using Scan to assign column data to struct fields. \tfor rows.Next() { var alb Album if err := rows.Scan(\u0026amp;alb.ID, \u0026amp;alb.Title, \u0026amp;alb.Artist, \u0026amp;alb.Price); err != nil { return nil, fmt.Errorf(\u0026#34;albumByArtist %q: %v\u0026#34;, name, err) } albums = append(albums, alb) } if err := rows.Err(); err != nil { return nil, fmt.Errorf(\u0026#34;albumByArtist %q: %v\u0026#34;, name, err) } return albums, nil }  Query 方法返回一个 *Rows 的指针，存放结果集。 defer rows.Close() 在函数退出阶段调用，防止连接泄漏。 rows.Scan 扫描当前行的列值分配给 Album 结构体。  查询单行 albumByID 函数：\n// albumByID queries for the album with the specified ID. func albumByID(id int64) (Album, error) { // An album to hold data from the returned row. \tvar alb Album row := db.QueryRow(\u0026#34;SELECT * FROM album WHERE id = ?\u0026#34;, id) if err := row.Scan(\u0026amp;alb.ID, \u0026amp;alb.Title, \u0026amp;alb.Artist, \u0026amp;alb.Price); err != nil { if err == sql.ErrNoRows { return alb, fmt.Errorf(\u0026#34;albumByID %d: no such album\u0026#34;, id) } return alb, fmt.Errorf(\u0026#34;albumByID %d: %v\u0026#34;, id, err) } return alb, nil } main 函数添加：\n// Hard-code ID 2 here to test the query. \talb, err := albumByID(2) if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;Album found: %v\\n\u0026#34;, alb) 添加数据 addAlbum 函数：\n// addAlbum adds the specified album to the database, returning the album ID of // the nuw entry func addAlbum(alb Album) (int64, error) { result, err := db.Exec(\u0026#34;INSERT INTO album (title, artist, price) VALUES (?, ?, ?)\u0026#34;, alb.Title, alb.Artist, alb.Price) if err != nil { return 0, fmt.Errorf(\u0026#34;addAlbum: %v\u0026#34;, err) } id, err := result.LastInsertId() if err != nil { return 0, fmt.Errorf(\u0026#34;addAlbum: %v\u0026#34;, err) } return id, nil }  db.Exec 方法执行不返回数据的 SQL 语句。 Result.LastInsertId 方法返回插入数据库行的 ID。  main 函数添加：\nalbID, err := addAlbum(Album{ Title: \u0026#34;The Modern Sound of Betty Carter\u0026#34;, Artist: \u0026#34;Betty Carter\u0026#34;, Price: 49.99, }) if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;ID of added album: %v\\n\u0026#34;, albID) 教程：使用 Gin 开发 RESTful API 创建数据 package main // album represents data about a record album. type album struct { ID string `json:\u0026#34;id\u0026#34;` Title string `json:\u0026#34;title\u0026#34;` Artist string `json:\u0026#34;artist\u0026#34;` Price float64 `json:\u0026#34;price\u0026#34;` } // albums slice to seed record album data. var albums = []album{ {ID: \u0026#34;1\u0026#34;, Title: \u0026#34;Blue Train\u0026#34;, Artist: \u0026#34;John Coltrane\u0026#34;, Price: 56.99}, {ID: \u0026#34;2\u0026#34;, Title: \u0026#34;Jeru\u0026#34;, Artist: \u0026#34;Gerry Mulligan\u0026#34;, Price: 17.99}, {ID: \u0026#34;3\u0026#34;, Title: \u0026#34;Sarah Vaughan and Clifford Brown\u0026#34;, Artist: \u0026#34;Sarah Vaughan\u0026#34;, Price: 39.99}, } 返回所有数据 import ( \u0026#34;net/http\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) // ...  func main() { router := gin.Default() router.GET(\u0026#34;/albums\u0026#34;, getAlbums) router.Run(\u0026#34;localhost:8080\u0026#34;) } // getAlbums responds with the list of all albums as JSON. func getAlbums(c *gin.Context) { c.IndentedJSON(http.StatusOK, albums) } go get . go run . curl http://localhost:8080/albums 添加新项 添加 postAlbums 函数：\n// postAlbums adds an album from JSON received in the request body. func postAlbums(c *gin.Context) { var newAlbum album // Call BindJSON to bind the received JSON to new Album. \tif err := c.BindJSON(\u0026amp;newAlbum); err != nil { return } // Add the new album to the slice. \talbums = append(albums, newAlbum) c.IndentedJSON(http.StatusCreated, newAlbum) } main 函数添加：\nrouter.POST(\u0026#34;/albums\u0026#34;, postAlbums) curl http://localhost:8080/albums \\ \t--include \\ \t--header \u0026#34;Content-Type: application/json\u0026#34; \\ \t--request \u0026#34;POST\u0026#34; \\ \t--data \u0026#39;{\u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;,\u0026#34;title\u0026#34;: \u0026#34;The Modern Sound of Betty Carter\u0026#34;,\u0026#34;artist\u0026#34;: \u0026#34;Betty Carter\u0026#34;,\u0026#34;price\u0026#34;: 49.99}\u0026#39; curl http://localhost:8080/albums \\ \t--header \u0026#34;Content-Type: application/json\u0026#34; \\ \t--request \u0026#34;GET\u0026#34; 返回特定项 getAlbumByID 函数：\n// getAlbumByID locates the album whose ID value matches the id parameter sent // by the client, then returns that album as a response. func getAlbumByID(c *gin.Context) { id := c.Param(\u0026#34;id\u0026#34;) // Loop over the list of albums, looking for an album whose ID value matches \t// the parameter. \tfor _, a := range albums { if a.ID == id { c.IndentedJSON(http.StatusOK, a) return } } c.IndentedJSON(http.StatusNotFound, gin.H{\u0026#34;message\u0026#34;: \u0026#34;album not found\u0026#34;}) } main 添加：\nrouter.GET(\u0026#34;/albums/:id\u0026#34;, getAlbumByID)  :id Gin 中路径前面有冒号表示该项是路径参数。  curl http://localhost:8080/albums/2 curl http://localhost:8080/albums/5 完整代码 package main import ( \u0026#34;net/http\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) // album represents data about a record album. type album struct { ID string `json:\u0026#34;id\u0026#34;` Title string `json:\u0026#34;title\u0026#34;` Artist string `json:\u0026#34;artist\u0026#34;` Price float64 `json:\u0026#34;price\u0026#34;` } // albums slice to seed record album data. var albums = []album{ {ID: \u0026#34;1\u0026#34;, Title: \u0026#34;Blue Train\u0026#34;, Artist: \u0026#34;John Coltrane\u0026#34;, Price: 56.99}, {ID: \u0026#34;2\u0026#34;, Title: \u0026#34;Jeru\u0026#34;, Artist: \u0026#34;Gerry Mulligan\u0026#34;, Price: 17.99}, {ID: \u0026#34;3\u0026#34;, Title: \u0026#34;Sarah Vaughan and Clifford Brown\u0026#34;, Artist: \u0026#34;Sarah Vaughan\u0026#34;, Price: 39.99}, } func main() { router := gin.Default() router.GET(\u0026#34;/albums\u0026#34;, getAlbums) router.GET(\u0026#34;/albums/:id\u0026#34;, getAlbumByID) router.POST(\u0026#34;/albums\u0026#34;, postAlbums) router.Run(\u0026#34;localhost:8080\u0026#34;) } // getAlbums responds with the list of all albums as JSON. func getAlbums(c *gin.Context) { c.IndentedJSON(http.StatusOK, albums) } // postAlbums adds an album from JSON received in the request body. func postAlbums(c *gin.Context) { var newAlbum album // Call BindJSON to bind the received JSON to new Album. \tif err := c.BindJSON(\u0026amp;newAlbum); err != nil { return } // Add the new album to the slice. \talbums = append(albums, newAlbum) c.IndentedJSON(http.StatusCreated, newAlbum) } // getAlbumByID locates the album whose ID value matches the id parameter sent // by the client, then returns that album as a response. func getAlbumByID(c *gin.Context) { id := c.Param(\u0026#34;id\u0026#34;) // Loop over the list of albums, looking for an album whose ID value matches \t// the parameter. \tfor _, a := range albums { if a.ID == id { c.IndentedJSON(http.StatusOK, a) return } } c.IndentedJSON(http.StatusNotFound, gin.H{\u0026#34;message\u0026#34;: \u0026#34;album not found\u0026#34;}) } "},{"uri":"https://www.shisanshiji.com/troubleshooting/","title":"问题排查","tags":null,"description":"","content":" 宝剑锋从磨砺出。 Elasticsearch 问题排查    "},{"uri":"https://www.shisanshiji.com/devops/","title":"DevOps","tags":null,"description":"","content":"DevOps。 Tekton CICD    "},{"uri":"https://www.shisanshiji.com/devops/tekton/","title":"Tekton CICD","tags":null,"description":"","content":"Tekton CICD Tekton 实践：安装    "},{"uri":"https://www.shisanshiji.com/operation-guide/kubernetes-%E5%BA%94%E7%94%A8%E4%BD%BF%E7%94%A8-keycloak-%E4%B8%8E-oauth2-proxy-%E8%BF%9B%E8%A1%8C%E8%AE%A4%E8%AF%81/","title":"使用 Keycloak 与 Oauth2-Proxy 认证 Kubernetes 应用","tags":null,"description":"","content":"安装 Keycloak-Operator # 1. 创建 keycloak 命名空间 kubectl create ns keycloak # 2. 创建 serviceaccount kubectl -n keycloak apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/service_account.yaml # 3. 创建 Role 和 Rolebinding（Namspace 范围） kubectl -n keycloak apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/role.yaml kubectl -n keycloak apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/role_binding.yaml # 这里创建的 keycloak-operator 为 namespace 范围，operator 只作用于 keycloak 这个 namespace 下。 # 如果需要 cluster 范围，需要改用 ClusterRole 和 ClusterRoleBinding # kubectl -n keycloak apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/cluster_roles/cluster_role.yaml # kubectl -n keycloak apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/cluster_roles/cluster_role_binding.yaml # 3. 安装 crds kubectl apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/crds/keycloak.org_keycloaks_crd.yaml kubectl apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/crds/keycloak.org_keycloakusers_crd.yaml kubectl apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/crds/keycloak.org_keycloakrealms_crd.yaml kubectl apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/crds/keycloak.org_keycloakclients_crd.yaml kubectl apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/crds/keycloak.org_keycloakbackups_crd.yaml # 安装 keycloak-operator kubectl -n keycloak apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/operator.yaml "},{"uri":"https://www.shisanshiji.com/categories/","title":"Categories","tags":null,"description":"","content":""},{"uri":"https://www.shisanshiji.com/tags/","title":"Tags","tags":null,"description":"","content":""},{"uri":"https://www.shisanshiji.com/","title":"十三时记","tags":null,"description":"","content":"无他，惟手熟尔。 分类   学习笔记  马上学不动了      操作指南  已经记不住了      问题排查  再相见也可能不认识了    "}]