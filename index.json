[{"uri":"https://www.shisanshiji.com/devops/chef/getting-started-with-automation/","title":"Chef - 自动化服务器配置管理工具入门","tags":null,"description":"","content":"在学习过程中，先通过实践去了解一门技术，了解这个技术可以做什么。然后在通过系统的学习去深入细节是最有效的方法。\n本文会使用 Chef 实现自动化管理，通过实践来对 Chef 的各个组件有一个大概的了解。\n1. Chef Infra Server 虽然我们可以通过使用 Chef Zero 在不运行完整的 Chef Infra Server 体验 Chef，但要获得完整的使用体验，最好运行本地或基于云端的 Chef Infra Server。部署完整的 Chef Infra Server 并不需要太多资源，它可以提供在目标节点之间存储和分发代码的完整体验。\n1.1. 先决条件  硬件最低配置：4 核 CPU、16GB 内存和 80GB 磁盘空间。 Linux 内核版本 3.2 以上并使用 systemd 作为 Init 系统。例如，Ubuntu 20.04 或 CentOS 8. 具有 sudo 权限的 非 root 用户。 具有静态 IP 地址并能够与你的 Workstation 和目标节点网络互通。 子网上具备 DNS 解析，实现 Chef Infra Server、节点和 Workstation 通过 FQDN 进行通信。如果没有内网 DNS 服务器，需要在 Chef Infra Server 和目标节点上的 hosts 文件，以便可以通过 name 互相访问。  本次 Chef Infra Server 实验环境为：\n         系统 Debian 11   内核 5.10.0-10-amd64   主机名 automate.chef.lab   配置 8 CPU、16GB 内存、50GB 磁盘空间   用户 sysadmin    1.2. 部署 Chef Infra Server   使用 hostnamectl set-hostname hostname 设置完全限定域名。之后的安装过程中默认将使用 FQDN 设置证书，因此配置文件中的 FQDN 值必须与系统的 hostname -f 值匹配。\n$ sudo hostnamectl set-hostname automate.chef.lab   安装 chef-automate 工具。\ncurl https://packages.chef.io/files/current/latest/chef-automate-cli/chef-automate_linux_amd64.zip | gunzip -\u0026gt; chef-automate \u0026amp;\u0026amp; chmod +x chef-automate   调整系统参数。\n$ echo \u0026#34;vm.max_map_count = 262144\u0026#34; | sudo tee -a /etc/sysctl.d/20-chef.conf $ echo \u0026#34;vm.dirty_expire_centisecs = 20000\u0026#34; | sudo tee -a /etc/sysctl.d/20-chef.conf $ sudo systemctl restart systemd-sysctl.service   使用 chef-automate 安装 Chef Infra Server。\n$ sudo ./chef-automate deploy --product infra-server ... Bootstrapping Chef Automate Fetching Release Manifest Installing Habitat Installing Habitat 1.6.181/20201030172917 Installing the Chef Automate deployment-service Installing supplementary Habitat packages Installing Habitat package automate-cli Installing Habitat package rsync Installing Habitat package hab-sup Installing Habitat package hab-launcher Installing Habitat systemd unit Skipping user and group creation (both already exist) Starting Habitat with systemd Bootstrapping deployment-service on localhost Configuring deployment-service Starting deployment-service Waiting for deployment-service to be ready Initializing connection to deployment-service Applying Deployment Configuration Starting deploy Installing deployment-service Installing automate-cli Installing backup-gateway Installing automate-postgresql Installing automate-pg-gateway Installing automate-elasticsearch Installing automate-es-gateway Installing pg-sidecar-service Installing es-sidecar-service Installing license-control-service Installing automate-cs-bookshelf Installing automate-cs-oc-bifrost Installing automate-cs-oc-erchef Installing automate-cs-nginx Installing automate-load-balancer Configuring deployment-service Starting backup-gateway Starting automate-postgresql Starting automate-pg-gateway Starting automate-elasticsearch Starting automate-es-gateway Starting pg-sidecar-service Starting es-sidecar-service Starting license-control-service Starting automate-cs-bookshelf Starting automate-cs-oc-bifrost Starting automate-cs-oc-erchef Starting automate-cs-nginx Starting automate-load-balancer Checking service health Deploy Complete Users of this Automate deployment may elect to share user-anonymized usage data with Chef Software, Inc. Chef uses this shared data to improve Automate. Please visit https://chef.io/privacy-policy for more information about the information Chef collects, and how that information is used.   1.3. 创建 Admin 用户和组织 使用 Chef Infra Server 需要创建一个管理用户并至少创建一个组织。用来提供 Server 与 Workstation 之间的安全访问。\n# Usage: chef-server-ctl user-create USERNAME FIRST_NAME [MIDDLE_NAME] LAST_NAME EMAIL PASSWORD $ sudo chef-server-ctl user-create admin Gao Peng peng.gao@ambow.com \u0026#34;password\u0026#34; --filename admin.pem # Usage: chef-server-ctl org-create ORG_SHORT_NAME ORG_FULL_NAME (options) $ sudo chef-server-ctl org-create lab \u0026#34;Ambow Lab\u0026#34; --association_user admin --filename lab-validator.pem 这两个命令会生成两个证书文件：admin.pem 和 lab-validator.pem。在第二节中，我们会复制 admin.pem 文件到 Worksation 中，以实现 Chef Infra Server 与 Workstation 之间的安全通信。\n2. Chef WorkStation 2.1. 先决条件  一个 Linux、Windows 或 MacOS Workstation。 能够访问外网。 和 Chef Infra Server 在同一个子网并网络互通。  本次 Chef Infra Server 实验环境为：\n         系统 Debian 11   内核 5.10.0-10-amd64   主机名 workstation.chef.lab   配置 4 CPU、8GB 内存、50GB 磁盘空间   用户 sysadmin    2.2. 安装 Chef Workstation Chef Workstation 是一组工具，通过它们可以使 Workstation 与 Server 交互。包括：chef、knife、inspec、cookstyle、habitat 和 kitchen。还包含 Ruby 和相关依赖项，使我们不需要安装其他任何包就可以使用 Chef Workstation 工具。\n安装步骤如下：\n  通过页面下载针对不同 OS 的安装包安装 Chef Workstation。\n$ curl -sLO https://packages.chef.io/files/stable/chef-workstation/21.12.720/debian/11/chef-workstation_21.12.720-1_amd64.deb \u0026amp;\u0026amp; sudo dpkg -i chef-workstation_21.12.720-1_amd64.deb Selecting previously unselected package chef-workstation. (Reading database ... 41805 files and directories currently installed.) Preparing to unpack chef-workstation_21.12.720-1_amd64.deb ... Unpacking chef-workstation (21.12.720-1) ... Setting up chef-workstation (21.12.720-1) ... Chef Workstation ships with a toolbar application, the Chef Workstation App. To run this application some additional dependencies must be installed. Using your platform\u0026#39;s package manager to install the \u0026#39;electron\u0026#39; package is the easiest way to meet the dependency requirements. You can then launch the App by running \u0026#39;chef-workstation-app\u0026#39;. The App will then be available in the system tray. Thank you for installing Chef Workstation! You can find some tips on getting started at https://docs.chef.io/workstation/getting_started/   初始化环境，将 Ruby 可执行路径添加至环境变量中并确保使用的 Ruby 版本为嵌入到 Workstation 中的 Ruby 版本。\n$ echo \u0026#39;eval \u0026#34;$(chef shell-init bash)\u0026#34;\u0026#39; \u0026gt;\u0026gt; $HOME/.bash_profile $ source $HOME/.bash_profile   验证安装。\n$ chef -v Chef Workstation version: 21.12.720 Chef InSpec version: 4.50.3 Chef CLI version: 5.4.2 Chef Habitat version: 1.6.420 Test Kitchen version: 3.2.2 Cookstyle version: 7.25.10 Chef Infra Client version: 17.8.25   2.3. 创建一个 Chef 仓库 使用 Chef 生成器生成一个仓库来存储我们编写的代码。\n$ chef generate repo chef-repo 我们通过 tree 命令观察生成的目录结构如下：\n$ tree -L 1 . ├── chefignore ├── cookbooks ├── data_bags ├── LICENSE ├── policyfiles └── README.md 可以观察到 chef generate repo 命令为我们编写代码提供了基本文件目录结构，简化了开发的所需的步骤。其中 cookbooks 目录会存放我们编写的所有食谱和配方，其他目录和文件的含义，我们在后续的学习和实践中会逐渐了解。\n2.4. 初始化系统 为了使 Workstation 能够与 Chef Infra Server 进行通信和交互，我们需要创建一个凭据。这个凭据需要存放在 HOME 目录下的 .chef 目录中。比如 /home/sysadmin/.chef。该目录和凭据可以使用生成器创建：\n$ knife configure init-config WARNING: No knife configuration file found. See https://docs.chef.io/config_rb/ for details. Please enter the chef server URL: [https://workstation.chef.lab/organizations/myorg] https://automate.chef.lab/organizations/lab Please enter an existing username or clientname for the API: [sysadmin] admin ***** You must place your client key in: /home/sysadmin/.chef/admin.pem Before running commands with Knife ***** Knife configuration file written to /home/sysadmin/.chef/credentials 运行上述命令时，终端会交互式向我们确认一些配置。其中包括 Chef Server 的 URL 和设置服务器时创建的用户名。运行完成后会生成 ~/.chef/credentials 文件，文件内容如下：\n[default] client_name = \u0026#39;admin\u0026#39; client_key = \u0026#39;/home/sysadmin/.chef/admin.pem\u0026#39; chef_server_url = \u0026#39;https://automate.chef.lab/organizations/lab\u0026#39; 编辑凭据文件添加默认的食谱位置，我们使用刚刚创建的 ~/chef-repo/cookbooks 作为默认的食谱路径，你还可以添加多个路径，比如 ['/path/to/one', '/path/to/two']。\ncookbook_path = [\u0026#39;~/chef-repo/cookbooks\u0026#39;] 最终我们的凭据文件内容如下：\n[default] client_name = \u0026#39;admin\u0026#39; client_key = \u0026#39;/home/sysadmin/.chef/admin.pem\u0026#39; chef_server_url = \u0026#39;https://automate.chef.lab/organizations/lab\u0026#39; cookbook_path = [\u0026#39;~/chef-repo/cookbooks\u0026#39;] 2.5. 从 Chef Infra Server 拷贝用户证书文件至 Workstation 刚才生成的凭据配置文件中 client_key 配置项指向 /home/sysadmin/.chef/admin.pem，因此需要从 Chef Infra Server 端拷贝至 Workstation 的 /home/sysadmin/.chef 目录下。\n$ cd ~/.chef $ scp sysadmin@automate.chef.lab:/home/sysadmin/admin.pem . 2.6. 获取并验证证书 使用 knife ssl fetch 命令获取证书，证书会将获取到的证书存放在 ~/.chef/trusted_certs 目录。此目录存放的证书用于提供安全通信，并且会信任此证书。\n$ knife ssl fetch WARNING: Certificates from automate.chef.lab will be fetched and placed in your trusted_cert directory (/home/sysadmin/.chef/trusted_certs). Knife has no means to verify these are the correct certificates. You should verify the authenticity of these certificates after downloading. Adding certificate for automate_chef_lab in /home/sysadmin/.chef/trusted_certs/automate_chef_lab.crt 接下来验证此证书。\n$ knife ssl check Connecting to host automate.chef.lab:443 Successfully verified certificates from `automate.chef.lab' 证书成功验证后，使用 knife client list 命令来验证 Workstation 和 Chef Infra Server 之间的连接，此命令将返回我们在配置 Chef Infra Server 时，所创建的客户端组织名称。\n$ knife client list lab-validator 2.7. 配置开发环境 完成了 Chef Infra Server 和 Chef Workstation 的配置后，我们可以开始使用 Chef 来配置和管理各个节点了。\n接着我们使用 VS Code 编辑器进行远程开发并配置好 Chef 插件。\n首先添加 Remote - SSH 插件能够在办公电脑上对 Workstation 进行远程开发。\n然后添加 Chef 扩展，包含自动化完成功能和内置的 Chef 语言参考，能够更加方便编写 Chef 代码。\n3. The Chef CookBook 接下来，我们创建一个简单的食谱，可以在运行 chef-client 代理的机器上进行各种操作。\n为了让 Chef 实现系统的自动化和合规性检测，Chef Infra Client 会通过\n3.1. 创建 Cookbook 在 Workstation 上，导航到 ~/chef-repo/cookbooks 目录并使用 chef generate cookbook 生成一个名为 run-chef-client 的食谱：\n$ cd ~/chef-repo/cookbooks/ $ chef generate cookbook run-chef-client -k dokken 运行完成后会生成 run-chef-client 目录，并初始化编写食谱所需的最小文件结构。-k dokken 选项会生成使用 Docker 作为驱动器的 Test Kitchen 预配置文件 kitchen.yml，我们将在后续步骤使用它。\n进入 run-chef-client 目录，列出生成的内容，了解 chef generate cookbook 生成的所有文件和目录。\n$ cd ~/chef-repo/cookbooks/run-chef-client $ tree . ├── CHANGELOG.md ├── chefignore ├── kitchen.yml ├── LICENSE ├── metadata.rb ├── Policyfile.rb ├── README.md ├── recipes │ └── default.rb └── test └── integration └── default └── default_test.rb 除了这些内容，还需要使用 chef generate attribute 生成一个可以保存属性的目录，再手动创建 ./compliance/profiles 保存合规性配置文件。\n$ cd ~/chef-repo/cookbooks/run-chef-client $ chef generate attribute default $ mkdir -p ./compliance/profiles 编辑 metadata.rb 文件，修改为维护者的信息。这些信息将自动传递到 Chef 生成器创建的文件当中，比如食谱、文件和模板：\nname \u0026#39;run-chef-client\u0026#39; maintainer \u0026#39;Thirteen\u0026#39; maintainer_email \u0026#39;thirteen@chef.lab\u0026#39; license \u0026#39;Apache-2.0\u0026#39; description \u0026#39;Set chef-client to run every 30 minutes\u0026#39; version \u0026#39;0.1.0\u0026#39; chef_version \u0026#39;\u0026gt;= 16.0\u0026#39; 我们也可以在生成食谱时就指定 maintainer、maintainer_email 和 license，例如：\n$ chef generate cookbook run-chef-client -k dokken -C \u0026#39;Thirteen\u0026#39; -m \u0026#39;thirteen@chef.lab\u0026#39; -I \u0026#39;apachev2\u0026#39; 创建配方 编辑 ./cookbooks/run-chef-client/recipes/default.rb 文件，并按需更新标题，例如替换作者。并确保用户名和密码能匹配你的环境。这个配方同时可以处理 Windows 和 Linux 系统上的操作。以后可能会有很多不同名称的配方，\n# # Cookbook:: run-chef-client # Recipe:: default # # Copyright:: 2021, Thirteen, All Rights Reserved. include_profile \u0026#39;run-chef-client::client-run\u0026#39; if platform?(\u0026#39;windows\u0026#39;) windows_task \u0026#39;run-chef-client\u0026#39; do user \u0026#39;WIN10\\jugggao\u0026#39; password \u0026#39;\u0026#39; command \u0026#39;chef-client\u0026#39; run_level :highest frequency :minute frequency_modifier 30 end else cron \u0026#39;Run chef-client every 30 minutes\u0026#39; do minute \u0026#39;0, 30\u0026#39; user \u0026#39;root\u0026#39; command \u0026#39;/usr/bin/chef-client\u0026#39; action :create end end The Chef InSpec Profile Chef InSpec Profiles 提供了对节点状态及合规性的洞察。也就是说，它会告诉我们所应用的食谱是否处于期望状态。\n"},{"uri":"https://www.shisanshiji.com/troubleshooting/elasticsearch-troubleshooting/","title":"Elasticsearch 问题排查","tags":null,"description":"","content":"问题列表如下：\n 集群中包含未分配的副本导致集群变为 Red 状态  集群中包含未分配的副本导致集群变为 Red 状态 查看集群状态信息 首先确定原因。\n查看整体健康信息 $ curl -u \u0026#39;elastic:password\u0026#39; \u0026#39;http://127.0.0.1:9200/_cluster/health?pretty\u0026#39; { \u0026#34;cluster_name\u0026#34; : \u0026#34;elasticsearch\u0026#34;, \u0026#34;status\u0026#34; : \u0026#34;red\u0026#34;, \u0026#34;timed_out\u0026#34; : false, \u0026#34;number_of_nodes\u0026#34; : 1, \u0026#34;number_of_data_nodes\u0026#34; : 1, \u0026#34;active_primary_shards\u0026#34; : 69, \u0026#34;active_shards\u0026#34; : 69, \u0026#34;relocating_shards\u0026#34; : 0, \u0026#34;initializing_shards\u0026#34; : 0, \u0026#34;unassigned_shards\u0026#34; : 1, \u0026#34;delayed_unassigned_shards\u0026#34; : 0, \u0026#34;number_of_pending_tasks\u0026#34; : 0, \u0026#34;number_of_in_flight_fetch\u0026#34; : 0, \u0026#34;task_max_waiting_in_queue_millis\u0026#34; : 0, \u0026#34;active_shards_percent_as_number\u0026#34; : 98.57142857142858 } 主要关注其中的 unassigned_shards 指标，其代表已经在集群状态中存在的分片，但是实际在集群里又找不着。通常未分配分片的来源是未分配的副本。比如，一个有 5 分片和 1 副本的索引，在单节点集群上，就会有 5 个未分配副本分片。如果你的集群是 red 状态，也会长期保有未分配分片（因为缺少主分片）。其他指标解释：\n  initializing_shards 是刚刚创建的分片的个数。比如，当你刚创建第一个索引，分片都会短暂的处于 initializing 状态。这通常会是一个临时事件，分片不应该长期停留在 initializing 状态。你还可能在节点刚重启的时候看到 initializing 分片：当分片从磁盘上加载后，它们会从 initializing 状态开始。\n  number_of_nodes 和 number_of_data_nodes：可由字面意思理解。\n  active_primary_shards：指出你集群中的主分片数量。这是涵盖了所有索引的汇总值。\n  active_shards：所有索引的所有分片的汇总值，即包括副本分片。\n  relocating_shards：显示当前正在从一个节点迁往其他节点的分片的数量。通常来说应该是 0，不过在 Elasticsearch 发现集群不太均衡时，该值会上涨。比如说：添加了一个新节点，或者下线了一个节点。\n  active_shards_percent_as_number：活跃分片数占总分片数比例。\n  查看每个索引的健康信息 我们还可以通过 level 参数查看更详细的信息：\ncurl -u elastic:password \u0026#39;http://127.0.0.1:9200/_cluster/health?pretty=true\u0026amp;level=indices\u0026#39; { \u0026#34;cluster_name\u0026#34; : \u0026#34;elasticsearch\u0026#34;, \u0026#34;status\u0026#34; : \u0026#34;red\u0026#34;, \u0026#34;timed_out\u0026#34; : false, \u0026#34;number_of_nodes\u0026#34; : 1, \u0026#34;number_of_data_nodes\u0026#34; : 1, \u0026#34;active_primary_shards\u0026#34; : 69, \u0026#34;active_shards\u0026#34; : 69, \u0026#34;relocating_shards\u0026#34; : 0, \u0026#34;initializing_shards\u0026#34; : 0, \u0026#34;unassigned_shards\u0026#34; : 2, \u0026#34;delayed_unassigned_shards\u0026#34; : 0, \u0026#34;number_of_pending_tasks\u0026#34; : 0, \u0026#34;number_of_in_flight_fetch\u0026#34; : 0, \u0026#34;task_max_waiting_in_queue_millis\u0026#34; : 0, \u0026#34;active_shards_percent_as_number\u0026#34; : 97.1830985915493, \u0026#34;indices\u0026#34; : { ... \u0026#34;kubernetes-2021.08.13\u0026#34; : { \u0026#34;status\u0026#34; : \u0026#34;green\u0026#34;, \u0026#34;number_of_shards\u0026#34; : 1, \u0026#34;number_of_replicas\u0026#34; : 0, \u0026#34;active_primary_shards\u0026#34; : 1, \u0026#34;active_shards\u0026#34; : 1, \u0026#34;relocating_shards\u0026#34; : 0, \u0026#34;initializing_shards\u0026#34; : 0, \u0026#34;unassigned_shards\u0026#34; : 1 }, ... } 添加 level=indices 参数会在集群健康信息里添加一个索引清单，以及有关每个索引的细节（状态、分片数、未分配分片数等等），一旦我们询问要索引的输出，哪个索引有问题立马就很清楚了：kubernetes-2021.08.13。\n查看每个索引的每个分片的健康信息 我们可以更细致的输出索引的每个分片的健康信息，通过添加参数 level=shards 获取。\ncurl -u \u0026#39;elastic:password\u0026#39; \u0026#39;http://127.0.0.1:9200/_cluster/health?pretty=true\u0026amp;level=shards\u0026#39; 通过添加 level=indices 参数可以列出每个索引里每个分片的状态和位置。这个输出有时候很有用，但是由于太过详细会比较难用。\n查看未分配分片的索引及原因 curl -u \u0026#39;elastic:password\u0026#39; \u0026#39;http://127.0.0.1:9200/_cat/shards?v\u0026amp;h=index,shard,prirep,state,unassigned.reason\u0026#39; index shard prirep state unassigned.reason .apm-custom-link 0 p STARTED ... kubernetes-2021.10.10 0 p STARTED kubernetes-2021.11.03 0 p UNASSIGNED CLUSTER_RECOVERED kubernetes-2021.08.19 0 p STARTED ... unassigned.reason 值说明：\n INDEX_CREATED: 由于创建索引的 API 导致未分配。 CLUSTER_RECOVERED: 由于完全集群恢复导致未分配。 INDEX_REOPENED: 由于打开 open 或关闭 close 一个索引导致未分配。 DANGLING_INDEX_IMPORTED: 由于导入 dangling 索引的结果导致未分配。 NEW_INDEX_RESTORED: 由于恢复到新索引导致未分配。 EXISTING_INDEX_RESTORED: 由于恢复到已关闭的索引导致未分配。 REPLICA_ADDED: 由于显式添加副本分片导致未分配。 ALLOCATION_FAILED: 由于分片分配失败导致未分配。 NODE_LEFT: 由于承载该分片的节点离开集群导致未分配。 REINITIALIZED: 由于当分片从开始移动到初始化时导致未分配（例如，使用Shadow 副本分片）。 REROUTE_CANCELLED: 作为显式取消重新路由命令的结果取消分配。 REALLOCATED_REPLICA: 确定更好的副本位置被标定使用，导致现有的副本分配被取消，出现未分配。  解决方法 由两种方法可解决，任选其中一种即可。\n手动分配 curl -u \u0026#39;elastic:password\u0026#39; -H \u0026#34;Content-Type: application/json\u0026#34; \u0026#39;http://127.0.0.1:9200/_cluster/reroute\u0026#39; -d \u0026#39;{ \u0026#34;commands\u0026#34;: [{ \u0026#34;allocate\u0026#34;: { \u0026#34;index\u0026#34;: \u0026#34;\u0026lt;索引名称\u0026gt;\u0026#34;, \u0026#34;shard\u0026#34;: \u0026lt;分片编号\u0026gt;, \u0026#34;node\u0026#34;: \u0026#34;\u0026lt;节点 ID\u0026gt;\u0026#34;, \u0026#34;allow_primary\u0026#34;: true } }] }\u0026#39; 批处理脚本：\n#!/bin/bash array=( node1 node2 node3 ) node_counter=0 length=${#array[@]} IFS=$\u0026#39;\\n\u0026#39; for line in $(curl -s \u0026#39;http://127.0.0.1:9200/_cat/shards\u0026#39;| fgrep UNASSIGNED); do INDEX=$(echo $line | (awk \u0026#39;{print $1}\u0026#39;)) SHARD=$(echo $line | (awk \u0026#39;{print $2}\u0026#39;)) NODE=${array[$node_counter]} echo $NODE curl -XPOST \u0026#39;http://127.0.0.1:9200/_cluster/reroute\u0026#39; -d \u0026#39;{ \u0026#34;commands\u0026#34;: [ { \u0026#34;allocate\u0026#34;: { \u0026#34;index\u0026#34;: \u0026#34;\u0026#39;$INDEX\u0026#39;\u0026#34;, \u0026#34;shard\u0026#34;: \u0026#39;$SHARD\u0026#39;, \u0026#34;node\u0026#34;: \u0026#34;\u0026#39;$NODE\u0026#39;\u0026#34;, \u0026#34;allow_primary\u0026#34;: true } } ] }\u0026#39; node_counter=$(((node_counter)%length +1)) done 重新建立副本 如果在上面的命令执行输出结果中，假如所有的 primary shards 都是正常的，所有 replica shards 有问题，有一种快速恢复的方法，就是强制删除掉 replica shards，让 Elasticsearch 自主重新生成。\n首先先将出问题的索引的副本为 0：\ncurl -u \u0026#39;elastic:password\u0026#39; -H \u0026#34;Content-Type: application/json\u0026#34; -X PUT \u0026#39;http://127.0.0.1:9200/\u0026lt;索引名称\u0026gt;/_settings\u0026#39; -d \u0026#39;{ \u0026#34;index\u0026#34;: {\u0026#34;number_of_replicas\u0026#34;: 0}}\u0026#39; 然后观察集群状态，最后通过命令在恢复期索引副本数据：\ncurl -u \u0026#39;elastic:password\u0026#39; -H \u0026#34;Content-Type: application/json\u0026#34; -X PUT \u0026#39;http://127.0.0.1:9200/\u0026lt;索引名称\u0026gt;/_settings\u0026#39; -d \u0026#39;{ \u0026#34;index\u0026#34;: {\u0026#34;number_of_replicas\u0026#34;: 1}}\u0026#39; 等待节点自动分配后，集群成功恢复成 green。\n"},{"uri":"https://www.shisanshiji.com/learning-notes/golang/go-install/","title":"Go 安装","tags":null,"description":"","content":"开发环境 使用 VSCode 编辑器。\n在 Debian 11 远程开发环境上开发。\n安装 wget https://golang.google.cn/dl/go1.17.4.linux-amd64.tar.gz rm -rf /usr/local/go \u0026amp;\u0026amp; tar -C /usr/local -xzf go1.17.4.linux-amd64.tar.gz echo -e \u0026#34;\\nexport PATH=\\$PATH:/usr/local/go/bin:\\$GOPATH/bin\u0026#34; | tee -a ~/.profile source ~/.profile go version 环境 go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.io,direct 编辑器 安装 vscode-go 插件。\n再安装开发工具。\n语法检测 go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest "},{"uri":"https://www.shisanshiji.com/learning-notes/golang/","title":"Golang 学习笔记","tags":null,"description":"","content":" Go 安装   Golang 教程    "},{"uri":"https://www.shisanshiji.com/operation-guide/hugo-githubactiongithub-pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","title":"Hugo\u0026Github Action\u0026Github Pages 搭建个人博客","tags":null,"description":"","content":"介绍 大致的流程如下：\n 首先通过 Hugo 生成博客网站，并进行配置、添加内容。 然后在 Github 上创建一个 blog 仓库，并将博客源码推送到 blog 仓库的 main 分支。 接着使用 Github Action 构建出静态网站，并自动推送至 gh-pages 分支。 最后配置 Github Pages 绑定 gh-pages 分支上的内容，就可以使用生成或配置的域名进行访问。  先决条件 准备 Git（必须） 如未安装 Git，参考 Git 安装指南 进行安装。\n安装完成后，可以通过 git version 命令进行验证。\n$ git version git version 2.29.2.windows.2 如果你是第一次安装，则需要初始化 Git 用户信息。将以下内容中邮箱和名字替换为合适的值并运行。\n$ git config --global user.email \u0026#34;you@example.com\u0026#34; $ git config --global user.name \u0026#34;Your Name\u0026#34; 准备 Github 仓库（必须） 在 Github 上创建 blog 仓库，你也可以选择其他合适的名称作为博客的仓库。\n点击查看配置仓库页面  准备 Hugo（必须） 如未安装 Hugo，参考 Hugo 安装指南 进行安装。\n安装完成后，可以通过 hugo version 命令进行验证。\n$ hugo version hugo v0.89.1-B6A4AE4A+extended windows/amd64 BuildDate=2021-11-05T15:44:32Z VendorInfo=gohugoio 准备域名（可选） 部署至 Github 上以后，默认会使用 \u0026lt;username\u0026gt;.github.io 域名访问你的博客。如果你想使用自己的域名，需要购买一个域名备用。可在腾讯云、阿里云或其他域名供应商购买。\n创建博客 生成博客 使用 hugo new site blog 命令来生成博客源码仓库。\n$ hugo new site blog Congratulations! Your new Hugo site is created in C:\\Users\\Peng.Gao\\Desktop\\Blog\\blog. Just a few more steps and you are ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; command. 2. Perhaps you want to add some content. You can add single files with \u0026#34;hugo new \u0026lt;SECTIONNAME\u0026gt;\\\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 3. Start the built-in live server via \u0026#34;hugo server\u0026#34;. Visit https://gohugo.io/ for quickstart guide and full documentation. 切换当前目录至 blog 目录，可以使用 tree 命令查看目录的结构。\n$ cd blog $ tree -L 1 . |-- archetypes |-- config.toml |-- content |-- data |-- layouts |-- static `-- themes 6 directories, 1 file 应用主题 你可以选择一个喜欢的主题应用于你的博客，此博客使用的主题为 Ace documentation。\n$ git submodule add https://github.com/vantagedesign/ace-documentation themes/ace-documentation Cloning into \u0026#39;C:/Users/Peng.Gao/Desktop/Blog/docs/themes/ace-documentation\u0026#39;... remote: Enumerating objects: 555, done. remote: Counting objects: 100% (139/139), done. remote: Compressing objects: 100% (90/90), done. remote: Total 555 (delta 57), reused 88 (delta 35), pack-reused 416 Receiving objects: 100% (555/555), 2.15 MiB | 683.00 KiB/s, done. Resolving deltas: 100% (191/191), done. warning: LF will be replaced by CRLF in .gitmodules. The file will have its original line endings in your working directory 接下来需要根据你应用主题的教程来配置 config.toml 文件，主题配置教程在刚才你寻找的主题页面上查看。\n还可以根据主题的样例去新添加一些内容，在此不过多说明。\n构建博客 配置完成后，在 blog 目录下可以使用 hugo server 启动 Web 服务器。Hugo 会构建站点内容到内存中并在检测到文件更改后重新渲染，方便在开发环境中实时预览对站点所做的更改。\n$ hugo server Start building sites … hugo v0.89.1-B6A4AE4A+extended windows/amd64 BuildDate=2021-11-05T15:44:32Z VendorInfo=gohugoio | EN -------------------+----- Pages | 18 Paginator pages | 0 Non-page files | 0 Static files | 26 Processed images | 0 Aliases | 0 Sitemaps | 1 Cleaned | 0 Built in 173 ms Watching for changes in C:\\Users\\Peng.Gao\\Desktop\\Blog\\docs\\{archetypes,content,data,layouts,static,themes} Watching for config changes in C:\\Users\\Peng.Gao\\Desktop\\Blog\\docs\\config.toml Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 如果你在远端开发，可以使用 hugo server --bind 0.0.0.0 配置绑定的网卡。 如果你想更换端口号，也可以使用 hugo server -p 80 配置监听端口号。 如果在调试阶段需要输出处于草稿状态的文章（通过在文章注释中添加 draft: true 配置），则需要使用 hugo server -D 来渲染草稿。\n想了解更多的选项，运行 hugo --help 来查看它们的说明。\n预览效果满意后，可以使用 hugo 命令进行构建。\n$ hugo Start building sites … hugo v0.89.1-B6A4AE4A+extended windows/amd64 BuildDate=2021-11-05T15:44:32Z VendorInfo=gohugoio | EN -------------------+----- Pages | 18 Paginator pages | 0 Non-page files | 0 Static files | 26 Processed images | 0 Aliases | 0 Sitemaps | 1 Cleaned | 0 Total in 200 ms 构建完成后，再观察 blog 目录，会发现出现了新的目录为 public，这个目录就是我们构建出来的静态网站，通过 tree 命令观察 public，就是一个静态页面的结构。\n$ tree -L 1 public/ public/ |-- 404.html |-- categories |-- css |-- img |-- index.html |-- index.json |-- js |-- learn-notes |-- lib |-- operation-guide |-- plugins |-- sitemap.xml |-- tags `-- webfonts 10 directories, 4 files 部署至 Github 推送博客源码 现在，我们就可以将 blog 目录中的源码推送至 Github 远程仓库的 main 分支了。\n但在推送前，应该还需要忽略一些文件。思考一下介绍时所描述的大致步骤，你的博客源码是存储在 main 分支的，经过自动构建才会最新生成的 public 文件中的内容推送至 gh-pages 分支，我们并不需要将 public 目录推送至 main 分支，因此需要忽略 public 目录。此外还可能需要忽略一些其他的文件或目录，比如启动 Web 服务时所生成的 .hugo_build.lock 文件和 resources 目录，或者由编辑器产生的本地配置目录及文件。以下是我在 .gitignore 文件中忽略的内容，仅供参考。\n*.lock *.vscode *.log *.idea resources/ public/ 添加完 .gitignore 文件以后，你可以添加 Github 远程仓库并推送至 main 分支。\n$ git init $ git add . $ git commit -m \u0026#34;init\u0026#34; $ git branch -M main $ git remote add origin https://github.com/jugggao/blog.git $ git push -u origin main  注意\n需要更换远程仓库 URL 中的名称为你的 Github 用户名。  使用 Github Action 自动构建 我们将博客源码上传至 main 分支之后，就需要通过 Github Action 进行自动构建了，并将生成的 public 目录中的内容推送至 gh-pages 分支。\n在 blog 目录下新建 .github/workflows/gh-pages.yml 文件，文件内容如下。\nname: Github Pages on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Read .env id: hugo-version run: |. ./.env echo \u0026#34;::set-output name=HUGO_VERSION::${HUGO_VERSION}\u0026#34; - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;${{ steps.hugo-version.outputs.HUGO_VERSION }}\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.ACTIONS_TOKEN }} publish_branch: gh-pages publish_dir: ./public cname: www.shisanshiji.com user_name: \u0026#39;jugggao\u0026#39; user_email: \u0026#39;jugg.gao@qq.com\u0026#39; commit_message: ${{ github.event.head_commit.message }} enable_jekyll: false allow_empty_commit: true 此 Github Action 的动作如下：\n 通过 on.push.branches: ['main'] 指定了只有在推送至 main 分支时才会触发此 Action。 Checkout 阶段进行拉取代码，包括子模块中的代码（上面你克隆的主题代码仓库）。 Read .env 阶段会读取当前目录中的 .env 文件中的 HUGO_VERSION 的值，并配置为当前 ACTION 的环境变量。 Setup hugo 阶段会根据刚才配置的 HUGO_VERSION 的版本号配置 Hugo 环境。 Build 阶段会进行源码构建，构建的静态网站存储在 public 目录。 Deploy 阶段通过 secrets.ACTIONS_TOKEN 值进行认证，认证过后再将构建的 public 目录中的内容推送到 gh-pages 分支。  注意\n 需要替换 Deploy 阶段 with.user_name 与 with.user_email 的值。 如果你不希望每次都拉取应用主题仓库的最新代码，可以将 Checkout 阶段的 with.submodules 的值改为 False。 如果你使用 Github 提供的默认域名，则需要删除 with.cname 这一行配置。   你会发现在推送之前还需要两个操作：\n 创建 .env 文件，并指定 Hugo 版本。 生成 Github Token 并在 blog 仓库中配置。  首先，在 blog 目录下 .env 文件，内容如下所示。你还可以将版本替换为你本地正在使用的版本以避免不确定的错误。\nHUGO_VERSION=0.89.1 然后，在 Github 中点击用户头像依次点击「Settings」 -\u0026gt; 「Developer settings」-\u0026gt;「Personal access tokens」-\u0026gt;「Generate new token」 来生成 Token。\n点击查看生成 Token 配置页面  最后，回到你的 blog 仓库，点击「Settings」-\u0026gt;「Secrets」-\u0026gt;「New repository secret」 添加刚才生成的 Token。名称需要和 gh-pages.yml 中引用的 ACTIONS_TOKEN 环境变量保持一致。\n点击查看添加 Token 配置页面  准备完成之后，将新添加的文件推送至远程仓库。\n$ git add . $ git commit -m \u0026#34;添加 Github Action 相关文件\u0026#34; $ git push -u origin main 这时，你可以在 blog 仓库页面中点击「Actions」观察 Wrokflows 的运行状况。如果发生错误，可以对每个阶段进行展开查看运行日志进行排查。\n点击查看 Github Action 运行页面  Github Action 运行成功后，你会发现在 blog 仓库中新增了 gh-pages 分支，分支的内容正是之前我们手动构建时生成的 public 目录下静态网站。\n配置 Github Pages 在 blog 仓库页面中依次点击「Settings」-\u0026gt;「Pages」。确定你开启了 Pages 功能并一切正常。\n点击查看 Github Pages 配置页面  如果你之前事前准备了自定义域名，可以参考 Github 官方文档 说明一步步配置自定义域名。配置完成后，可以勾选「Enforce HTTPS」 选项并由 Github 自动为你的域名颁发 SSL 证书。\n验证博客访问 最后，在浏览器中输入你的博客网址来验收成果。\n参考  GitHub Pages Documentation Hugo+GitHub Action+Github Pages搭建个人博客 Ace documentation  "},{"uri":"https://www.shisanshiji.com/devops/tekton/tekton-practice-task/","title":"Tekton 实践：安装","tags":null,"description":"","content":""},{"uri":"https://www.shisanshiji.com/learning-notes/","title":"学习笔记","tags":null,"description":"","content":"入门到放弃或从入门到入土。 Golang 学习笔记    "},{"uri":"https://www.shisanshiji.com/operation-guide/","title":"操作指南","tags":null,"description":"","content":"好记性不如烂笔头。 Hugo\u0026amp;Github Action\u0026amp;Github Pages 搭建个人博客   使用 Keycloak 与 Oauth2-Proxy 认证 Kubernetes 应用    "},{"uri":"https://www.shisanshiji.com/learning-notes/golang/go-tutorial/","title":"Golang 教程","tags":null,"description":"","content":"教程：开始 mkdir hello cd hello go mod init example/hello vim hello.go package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } go run . 引用外部包。\npackage main import \u0026#34;fmt\u0026#34; import \u0026#34;rsc.io/quote\u0026#34; func main() { fmt.Println(quote.Go()) } 下载外部包，并在 go.mod 中添加依赖以及生成认证文件 go.sum。\ngo mod tidy 教程：创建一个 Go 模块 创建模块 mkdir greetings cd greetings/ go mod init example.com/greetings vim greetings.go package greetings import \u0026#34;fmt\u0026#34; // Hello returns a greeting for the named person func Hello(name string) string { // Return a greeting that embeds the the in a message.  message := fmt.Sprintf(\u0026#34;Hi, %v. Welcome!\u0026#34;, name) return message } 调用其他模块 此时目录结构为：\n. ├── greetings └── hello cd hello rm -rf * go mod init example.com/hello vim hello.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;example.com/greetings\u0026#34; ) func main() { // Get a greeting message and print it. \tmessage := greetings.Hello(\u0026#34;Gladys\u0026#34;) fmt.Println(message) } 重定向 Go 模块路径并添加依赖：\ngo mod edit -replace example.com/greetings=../greetings go mod tidy 运行：\ngo run . 错误处理 greetings.go：\npackage greetings import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) // Hello returns a greeting for the named person func Hello(name string) (string, error) { // If no name was given, return an error with a message. \tif name == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;empty name\u0026#34;) } // If a name was received, Return a greeting that embeds the the \t// in a message. \tmessage := fmt.Sprintf(\u0026#34;Hi, %v. Welcome!\u0026#34;, name) return message, nil } hello.go：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;example.com/greetings\u0026#34; ) func main() { // Set properties of the predefined Logger, including the log \t// entry prefix and a flag to disable printing the time, source \t// file, and line number. \tlog.SetPrefix(\u0026#34;greetings: \u0026#34;) log.SetFlags(0) // Request a greeting message. \tmessage, err := greetings.Hello(\u0026#34;\u0026#34;) // If an error was returned, print it to the console and exit the program. \tif err != nil { log.Fatal(err) } // If no error was returned, print the returned message to the massage. \tfmt.Println(message) } 随机问候 greetings.go:\npackage greetings import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) // Hello returns a greeting for the named person func Hello(name string) (string, error) { // If no name was given, return an error with a message. \tif name == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;empty name\u0026#34;) } // If a name was received, Return a greeting that embeds the the in a \t// message. \tmessage := fmt.Sprintf(randomFormat(), name) return message, nil } // init sets initial values for variables used in the fuction. func init() { rand.Seed(time.Now().UnixNano()) } // randomFormat returns one of a set of greeting messages. The returned message // is selected at random. func randomFormat() string { // A slice of message formats. \tformats := []string{ \u0026#34;Hi, %v. Welcome!\u0026#34;, \u0026#34;Great to see you, %v!\u0026#34;, \u0026#34;Hail, %v! Well met!\u0026#34;, } // Return a randomly selected message format by specifying a random index \t// for the slice of formats. \treturn formats[rand.Intn(len(formats))] } hello.go：\nmessage, err := greetings.Hello(\u0026#34;Gladys\u0026#34;) 多人问候 greetings.go：\npackage greetings import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) // Hello returns a greeting for the named person func Hello(name string) (string, error) { // If no name was given, return an error with a message. \tif name == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;empty name\u0026#34;) } // If a name was received, Return a greeting that embeds the the in a \t// message. \tmessage := fmt.Sprintf(randomFormat(), name) return message, nil } // Hellos returns a map that associates each of the named people with a greeting // message. func Hellos(names []string) (map[string]string, error) { // A map to associate names with messages. \tmessages := make(map[string]string) // Loop through the received slice of names, calling the Hello function to \t// get a message for each name. \tfor _, name := range names { message, err := Hello(name) if err != nil { return nil, err } // In the map, associate the retrieved message with the name. \tmessages[name] = message } return messages, nil } hello.go\nfunc main() { // Set properties of the predefined Logger, including the log \t// entry prefix and a flag to disable printing the time, source \t// file, and line number. \tlog.SetPrefix(\u0026#34;greetings: \u0026#34;) log.SetFlags(0) // A slice of names. \tnames := []string{\u0026#34;Gladys\u0026#34;, \u0026#34;Samantha\u0026#34;, \u0026#34;Darrin\u0026#34;} // Request greeting messages for the names. \tmessages, err := greetings.Hellos(names) // If an error was returned, print it to the console and exit the program. \tif err != nil { log.Fatal(err) } // If no error was returned, print the returned message to the massage. \tfmt.Println(messages) } 测试 greetings_test.go：\npackage greetings import ( \u0026#34;regexp\u0026#34; \u0026#34;testing\u0026#34; ) // TestHelloName calls greetings.Hello with a name, cheking for a vaild return // value. func TestHelloName(t *testing.T) { name := \u0026#34;Gladys\u0026#34; want := regexp.MustCompile(`\\b` + name + `\\b`) msg, err := Hello(\u0026#34;Gladys\u0026#34;) if !want.MatchString(msg) || err != nil { t.Fatalf(`Hello(\u0026#34;Gladys\u0026#34;) = %q, %v, want match for %#q, nil`, msg, err, want) } } // TestHelloEmpty calls greetings.Hello with an empty string, checking for an // error. func TestHelloEmpty(t *testing.T) { msg, err := Hello(\u0026#34;\u0026#34;) if msg != \u0026#34;\u0026#34; || err == nil { t.Fatalf(`Hello(\u0026#34;\u0026#34;) = %q, %v, want \u0026#34;\u0026#34;, error`, msg, err) } } 编译安装 编译：\ngo build ./hello 安装：\n# 显示安装目录 go list -f \u0026#39;{{ .Target }}\u0026#39; # 配置环境变量 export PATH=$PATH:/path/to/your/install/directory # 安装 go install # 运行 hello 教程：访问关系型数据库 准备 安装 MySQL：\ndocker run -itd --name mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 mysql:5.7 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci mkdir data-access cd data-access go mod init example/data-access 初始化数据库 docker exec -ti mysql mysql -u root -p123456 创建数据库：\ncreate database recordings; create-tables.sql：\nDROP TABLE IF EXISTS album; CREATE TABLE album ( id\tINT AUTO_INCREMENT NOT NULL, title\tVARCHAR(128) NOT NULL, artist\tVARCHAR(128) NOT NULL, price\tDECIMAL(5,2) NOT NULL, PRIMARY KEY (`id`) ); INSERT INTO album (title, artist, price) VALUES (\u0026#39;Blue Train\u0026#39;, \u0026#39;John Coltrane\u0026#39;, 56.99), (\u0026#39;Giant Steps\u0026#39;, \u0026#39;John Coltrane\u0026#39;, 63.99), (\u0026#39;Jeru\u0026#39;, \u0026#39;Gerry Mulligan\u0026#39;, 17.99), (\u0026#39;Sarah Vaughan\u0026#39;, \u0026#39;Sarah Vaughan\u0026#39;, 34.98); 初始化数据：\ndocker exec -ti mysql mysql -uroot -p123456 recordings -e \u0026#34;source /tmp/create-tables.sql mysql\u0026gt; select * from album; +----+---------------+----------------+-------+ | id | title | artist | price | +----+---------------+----------------+-------+ | 1 | Blue Train | John Coltrane | 56.99 | | 2 | Giant Steps | John Coltrane | 63.99 | | 3 | Jeru | Gerry Mulligan | 17.99 | | 4 | Sarah Vaughan | Sarah Vaughan | 34.98 | +----+---------------+----------------+-------+ 获取数据库句柄并链接 main.go\npackage main import ( \u0026#34;database/sql\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/go-sql-driver/mysql\u0026#34; ) var db *sql.DB func main() { // Capture connection properties. \tcfg := mysql.Config{ User: os.Getenv(\u0026#34;DBUSER\u0026#34;), Passwd: os.Getenv(\u0026#34;DBPASS\u0026#34;), Net: \u0026#34;tcp\u0026#34;, Addr: \u0026#34;127.0.0.1:3306\u0026#34;, DBName: \u0026#34;recordings\u0026#34;, AllowNativePasswords: true, } // Get a database handle. \tvar err error db, err = sql.Open(\u0026#34;mysql\u0026#34;, cfg.FormatDSN()) if err != nil { log.Fatal(err) } pingErr := db.Ping() if pingErr != nil { log.Fatal(pingErr) } fmt.Println(\u0026#34;Connected!\u0026#34;) }  sql.DB 表示一个连接池。 sql.Open 的第一个参数是驱动名称。 cfg.FormatDSN() 将配置转换为 \u0026ldquo;User:Passwd@tcp(127.0.0.1:3306)/recordings\u0026rdquo;。 db.Ping() 检查数据库连通性。  go get . go run . 查询多行 package main import ( \u0026#34;database/sql\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/go-sql-driver/mysql\u0026#34; ) var db *sql.DB type Album struct { ID int64 Title string Artist string Price float32 } func main() { // Capture connection properties. \tcfg := mysql.Config{ User: os.Getenv(\u0026#34;DBUSER\u0026#34;), Passwd: os.Getenv(\u0026#34;DBPASS\u0026#34;), Net: \u0026#34;tcp\u0026#34;, Addr: \u0026#34;127.0.0.1:3306\u0026#34;, DBName: \u0026#34;recordings\u0026#34;, AllowNativePasswords: true, } // Get a database handle. \tvar err error db, err = sql.Open(\u0026#34;mysql\u0026#34;, cfg.FormatDSN()) if err != nil { log.Fatal(err) } pingErr := db.Ping() if pingErr != nil { log.Fatal(pingErr) } fmt.Println(\u0026#34;Connected!\u0026#34;) albums, err := albumByArtist(\u0026#34;John Coltrane\u0026#34;) if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;Albums found: %v\\n\u0026#34;, albums) } // albumByArtist queries for album that have the specified artist name. func albumByArtist(name string) ([]Album, error) { // An album slice to hold data from returned rows. \tvar albums []Album rows, err := db.Query(\u0026#34;SELECT * FROM album WHERE artist = ?\u0026#34;, name) if err != nil { return nil, fmt.Errorf(\u0026#34;albumByArtist %q: %v\u0026#34;, name, err) } defer rows.Close() // Loop through rows, using Scan to assign column data to struct fields. \tfor rows.Next() { var alb Album if err := rows.Scan(\u0026amp;alb.ID, \u0026amp;alb.Title, \u0026amp;alb.Artist, \u0026amp;alb.Price); err != nil { return nil, fmt.Errorf(\u0026#34;albumByArtist %q: %v\u0026#34;, name, err) } albums = append(albums, alb) } if err := rows.Err(); err != nil { return nil, fmt.Errorf(\u0026#34;albumByArtist %q: %v\u0026#34;, name, err) } return albums, nil }  Query 方法返回一个 *Rows 的指针，存放结果集。 defer rows.Close() 在函数退出阶段调用，防止连接泄漏。 rows.Scan 扫描当前行的列值分配给 Album 结构体。  查询单行 albumByID 函数：\n// albumByID queries for the album with the specified ID. func albumByID(id int64) (Album, error) { // An album to hold data from the returned row. \tvar alb Album row := db.QueryRow(\u0026#34;SELECT * FROM album WHERE id = ?\u0026#34;, id) if err := row.Scan(\u0026amp;alb.ID, \u0026amp;alb.Title, \u0026amp;alb.Artist, \u0026amp;alb.Price); err != nil { if err == sql.ErrNoRows { return alb, fmt.Errorf(\u0026#34;albumByID %d: no such album\u0026#34;, id) } return alb, fmt.Errorf(\u0026#34;albumByID %d: %v\u0026#34;, id, err) } return alb, nil } main 函数添加：\n// Hard-code ID 2 here to test the query. \talb, err := albumByID(2) if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;Album found: %v\\n\u0026#34;, alb) 添加数据 addAlbum 函数：\n// addAlbum adds the specified album to the database, returning the album ID of // the nuw entry func addAlbum(alb Album) (int64, error) { result, err := db.Exec(\u0026#34;INSERT INTO album (title, artist, price) VALUES (?, ?, ?)\u0026#34;, alb.Title, alb.Artist, alb.Price) if err != nil { return 0, fmt.Errorf(\u0026#34;addAlbum: %v\u0026#34;, err) } id, err := result.LastInsertId() if err != nil { return 0, fmt.Errorf(\u0026#34;addAlbum: %v\u0026#34;, err) } return id, nil }  db.Exec 方法执行不返回数据的 SQL 语句。 Result.LastInsertId 方法返回插入数据库行的 ID。  main 函数添加：\nalbID, err := addAlbum(Album{ Title: \u0026#34;The Modern Sound of Betty Carter\u0026#34;, Artist: \u0026#34;Betty Carter\u0026#34;, Price: 49.99, }) if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;ID of added album: %v\\n\u0026#34;, albID) 教程：使用 Gin 开发 RESTful API 创建数据 package main // album represents data about a record album. type album struct { ID string `json:\u0026#34;id\u0026#34;` Title string `json:\u0026#34;title\u0026#34;` Artist string `json:\u0026#34;artist\u0026#34;` Price float64 `json:\u0026#34;price\u0026#34;` } // albums slice to seed record album data. var albums = []album{ {ID: \u0026#34;1\u0026#34;, Title: \u0026#34;Blue Train\u0026#34;, Artist: \u0026#34;John Coltrane\u0026#34;, Price: 56.99}, {ID: \u0026#34;2\u0026#34;, Title: \u0026#34;Jeru\u0026#34;, Artist: \u0026#34;Gerry Mulligan\u0026#34;, Price: 17.99}, {ID: \u0026#34;3\u0026#34;, Title: \u0026#34;Sarah Vaughan and Clifford Brown\u0026#34;, Artist: \u0026#34;Sarah Vaughan\u0026#34;, Price: 39.99}, } 返回所有数据 import ( \u0026#34;net/http\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) // ...  func main() { router := gin.Default() router.GET(\u0026#34;/albums\u0026#34;, getAlbums) router.Run(\u0026#34;localhost:8080\u0026#34;) } // getAlbums responds with the list of all albums as JSON. func getAlbums(c *gin.Context) { c.IndentedJSON(http.StatusOK, albums) } go get . go run . curl http://localhost:8080/albums 添加新项 添加 postAlbums 函数：\n// postAlbums adds an album from JSON received in the request body. func postAlbums(c *gin.Context) { var newAlbum album // Call BindJSON to bind the received JSON to new Album. \tif err := c.BindJSON(\u0026amp;newAlbum); err != nil { return } // Add the new album to the slice. \talbums = append(albums, newAlbum) c.IndentedJSON(http.StatusCreated, newAlbum) } main 函数添加：\nrouter.POST(\u0026#34;/albums\u0026#34;, postAlbums) curl http://localhost:8080/albums \\ \t--include \\ \t--header \u0026#34;Content-Type: application/json\u0026#34; \\ \t--request \u0026#34;POST\u0026#34; \\ \t--data \u0026#39;{\u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;,\u0026#34;title\u0026#34;: \u0026#34;The Modern Sound of Betty Carter\u0026#34;,\u0026#34;artist\u0026#34;: \u0026#34;Betty Carter\u0026#34;,\u0026#34;price\u0026#34;: 49.99}\u0026#39; curl http://localhost:8080/albums \\ \t--header \u0026#34;Content-Type: application/json\u0026#34; \\ \t--request \u0026#34;GET\u0026#34; 返回特定项 getAlbumByID 函数：\n// getAlbumByID locates the album whose ID value matches the id parameter sent // by the client, then returns that album as a response. func getAlbumByID(c *gin.Context) { id := c.Param(\u0026#34;id\u0026#34;) // Loop over the list of albums, looking for an album whose ID value matches \t// the parameter. \tfor _, a := range albums { if a.ID == id { c.IndentedJSON(http.StatusOK, a) return } } c.IndentedJSON(http.StatusNotFound, gin.H{\u0026#34;message\u0026#34;: \u0026#34;album not found\u0026#34;}) } main 添加：\nrouter.GET(\u0026#34;/albums/:id\u0026#34;, getAlbumByID)  :id Gin 中路径前面有冒号表示该项是路径参数。  curl http://localhost:8080/albums/2 curl http://localhost:8080/albums/5 完整代码 package main import ( \u0026#34;net/http\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) // album represents data about a record album. type album struct { ID string `json:\u0026#34;id\u0026#34;` Title string `json:\u0026#34;title\u0026#34;` Artist string `json:\u0026#34;artist\u0026#34;` Price float64 `json:\u0026#34;price\u0026#34;` } // albums slice to seed record album data. var albums = []album{ {ID: \u0026#34;1\u0026#34;, Title: \u0026#34;Blue Train\u0026#34;, Artist: \u0026#34;John Coltrane\u0026#34;, Price: 56.99}, {ID: \u0026#34;2\u0026#34;, Title: \u0026#34;Jeru\u0026#34;, Artist: \u0026#34;Gerry Mulligan\u0026#34;, Price: 17.99}, {ID: \u0026#34;3\u0026#34;, Title: \u0026#34;Sarah Vaughan and Clifford Brown\u0026#34;, Artist: \u0026#34;Sarah Vaughan\u0026#34;, Price: 39.99}, } func main() { router := gin.Default() router.GET(\u0026#34;/albums\u0026#34;, getAlbums) router.GET(\u0026#34;/albums/:id\u0026#34;, getAlbumByID) router.POST(\u0026#34;/albums\u0026#34;, postAlbums) router.Run(\u0026#34;localhost:8080\u0026#34;) } // getAlbums responds with the list of all albums as JSON. func getAlbums(c *gin.Context) { c.IndentedJSON(http.StatusOK, albums) } // postAlbums adds an album from JSON received in the request body. func postAlbums(c *gin.Context) { var newAlbum album // Call BindJSON to bind the received JSON to new Album. \tif err := c.BindJSON(\u0026amp;newAlbum); err != nil { return } // Add the new album to the slice. \talbums = append(albums, newAlbum) c.IndentedJSON(http.StatusCreated, newAlbum) } // getAlbumByID locates the album whose ID value matches the id parameter sent // by the client, then returns that album as a response. func getAlbumByID(c *gin.Context) { id := c.Param(\u0026#34;id\u0026#34;) // Loop over the list of albums, looking for an album whose ID value matches \t// the parameter. \tfor _, a := range albums { if a.ID == id { c.IndentedJSON(http.StatusOK, a) return } } c.IndentedJSON(http.StatusNotFound, gin.H{\u0026#34;message\u0026#34;: \u0026#34;album not found\u0026#34;}) } "},{"uri":"https://www.shisanshiji.com/devops/chef/","title":"Tekton CICD","tags":null,"description":"","content":"Chef Chef - 自动化服务器配置管理工具入门    "},{"uri":"https://www.shisanshiji.com/devops/tekton/","title":"Tekton CICD","tags":null,"description":"","content":"Tekton CICD Tekton 实践：安装    "},{"uri":"https://www.shisanshiji.com/troubleshooting/","title":"问题排查","tags":null,"description":"","content":" 宝剑锋从磨砺出。 Elasticsearch 问题排查    "},{"uri":"https://www.shisanshiji.com/devops/","title":"DevOps","tags":null,"description":"","content":"DevOps。 Tekton CICD   Tekton CICD    "},{"uri":"https://www.shisanshiji.com/operation-guide/kubernetes-%E5%BA%94%E7%94%A8%E4%BD%BF%E7%94%A8-keycloak-%E4%B8%8E-oauth2-proxy-%E8%BF%9B%E8%A1%8C%E8%AE%A4%E8%AF%81/","title":"使用 Keycloak 与 Oauth2-Proxy 认证 Kubernetes 应用","tags":null,"description":"","content":"安装 Keycloak-Operator # 1. 创建 keycloak 命名空间 kubectl create ns keycloak # 2. 创建 serviceaccount kubectl -n keycloak apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/service_account.yaml # 3. 创建 Role 和 Rolebinding（Namspace 范围） kubectl -n keycloak apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/role.yaml kubectl -n keycloak apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/role_binding.yaml # 这里创建的 keycloak-operator 为 namespace 范围，operator 只作用于 keycloak 这个 namespace 下。 # 如果需要 cluster 范围，需要改用 ClusterRole 和 ClusterRoleBinding # kubectl -n keycloak apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/cluster_roles/cluster_role.yaml # kubectl -n keycloak apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/cluster_roles/cluster_role_binding.yaml # 3. 安装 crds kubectl apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/crds/keycloak.org_keycloaks_crd.yaml kubectl apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/crds/keycloak.org_keycloakusers_crd.yaml kubectl apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/crds/keycloak.org_keycloakrealms_crd.yaml kubectl apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/crds/keycloak.org_keycloakclients_crd.yaml kubectl apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/crds/keycloak.org_keycloakbackups_crd.yaml # 安装 keycloak-operator kubectl -n keycloak apply -f https://raw.githubusercontent.com/keycloak/keycloak-operator/master/deploy/operator.yaml "},{"uri":"https://www.shisanshiji.com/categories/","title":"Categories","tags":null,"description":"","content":""},{"uri":"https://www.shisanshiji.com/tags/","title":"Tags","tags":null,"description":"","content":""},{"uri":"https://www.shisanshiji.com/","title":"十三时记","tags":null,"description":"","content":"折腾日记 分类   Linux 折腾日记  玩点不一样      操作指南  已经记不住了      问题排查  再相见也可能不认识了    "}]